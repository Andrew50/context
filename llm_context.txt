# Inputs

## Current File
Here is the file I'm looking at. It might be truncated from above and below and, if so, is centered around my cursor.

<potential_codebase_context>
## Potentially Relevant Code Snippets from the current Codebase

```popups/input.svelte
<file></file>

```

```src/routes/app/+page.svelte
<file>/home/aj/dev/study/services/frontend/src/routes/app/+page.svelte</file>
<script lang="ts">
	import '$lib/core/global.css';
	import ChartContainer from '$lib/features/chart/chartContainer.svelte';
	import Alerts from '$lib/features/alerts/alert.svelte';
	import RightClick from '$lib/utils/popups/rightClick.svelte';
	import Setup from '$lib/utils/popups/setup.svelte';
	import Input from '$lib/utils/popups/input.svelte';
	import Similar from '$lib/features/similar/similar.svelte';
	import Study from '$lib/features/study.svelte';
	import Journal from '$lib/features/journal.svelte';
	import Watchlist from '$lib/features/watchlist.svelte';
	//import TickerInfo from '$lib/features/quotes/tickerInfo.svelte';
	import Quote from '$lib/features/quotes/quote.svelte';
	import Algo from '$lib/utils/popups/algo.svelte';
	import { activeMenu, changeMenu } from '$lib/core/stores';

	// Windows that will be opened in draggable divs
	import Screener from '$lib/features/screen.svelte';
	import Account from '$lib/features/account.svelte';
	import Active from '$lib/features/active.svelte';
	import Setups from '$lib/features/setups/setups.svelte';
	import Options from '$lib/features/options.svelte';
	import Settings from '$lib/features/settings.svelte';
	import Newsfeed from '$lib/features/newsfeed.svelte';

	// Replay logic
	import {
		startReplay,
		stopReplay,
		pauseReplay,
		resumeReplay,
		changeSpeed,
		nextDay
	} from '$lib/utils/stream/interface';
	import { queryInstanceInput } from '$lib/utils/popups/input.svelte';
	import { browser } from '$app/environment';
	import { onMount, onDestroy } from 'svelte';
	import { privateRequest } from '$lib/core/backend';
	import { goto } from '$app/navigation';
	import {
		initStores,
		streamInfo,
		formatTimestamp,
		dispatchMenuChange,
		menuWidth
	} from '$lib/core/stores';
	import { writable, type Writable } from 'svelte/store';

	// Import Instance from types
	import type { Instance } from '$lib/core/types';

	// Add import near the top with other imports
	import Screensaver from '$lib/features/screensaver.svelte';

	// Add new import for Query component
	import Query from '$lib/features/query.svelte';

	// Import the new input store
	import { openInputWindow } from '$lib/utils/popups/inputStore';

	type Menu = 'none' | 'watchlist' | 'alerts' | 'study' | 'journal' | 'similar';

	// Initialize all sidebar state variables as closed
	let lastSidebarMenu: Menu | null = null;
	let sidebarWidth = 0;
	const sidebarMenus: Menu[] = ['watchlist', 'alerts', 'study', 'journal', 'similar'];

	// Initialize chartWidth with a default value
	let chartWidth = 0;

	// Bottom windows
	type BottomWindowType =
		| 'screener'
		| 'account'
		| 'active'
		| 'options'
		| 'setups'
		| 'settings'
		| 'newsfeed'
		| 'query';
	interface BottomWindow {
		id: number;
		type: BottomWindowType;
		x: number;
		y: number;
		width: number;
		height: number;
		visible: boolean;
	}

	let bottomWindows: BottomWindow[] = [];
	let nextWindowId = 1;

	// Replay controls
	let replaySpeed = 1.0;

	// Resizing the bottom windows
	let bottomWindowsHeight = 0;
	let bottomResizing = false;
	const MIN_BOTTOM_HEIGHT = 50;
	const MAX_BOTTOM_HEIGHT = 1200;

	// Add these state variables near the top with other state declarations
	let lastBottomWindow: BottomWindow | null = null;

	// Initialize with default question mark avatar
	let profilePic = '';
	let username = '';
	let profilePicError = false;
	let profileIconKey = 0;
	let currentProfileDisplay = ''; // Add this to hold the current display value

	let sidebarResizing = false;
	let tickerHeight = 300; // Initial height
	const MIN_TICKER_HEIGHT = 100;
	const MAX_TICKER_HEIGHT = 600;

	// Add state variables after other state declarations
	let screensaverActive = false;
	let inactivityTimer: ReturnType<typeof setTimeout> | null = null;
	const INACTIVITY_TIMEOUT = 5 * 1000; // 5 seconds in milliseconds

	// Add a reactive statement to handle window events
	$: if (draggingWindowId !== null) {
		if (browser) {
			window.addEventListener('mousemove', onDrag);
			window.addEventListener('mouseup', stopDrag);
		}
	} else {
		if (browser) {
			window.removeEventListener('mousemove', onDrag);
			window.removeEventListener('mouseup', stopDrag);
		}
	}

	// Add reactive statement to update chart width when menuWidth changes

	function updateChartWidth() {
		if (browser) {
			const sidebarWidth = $menuWidth;
			const maxSidebarWidth = Math.min(500, window.innerWidth - 60);

			// Only reduce chart width if sidebar width is within bounds
			if (sidebarWidth <= maxSidebarWidth) {
				chartWidth = window.innerWidth - sidebarWidth - 60;
			}
		}
	}

	let keydownHandler: (event: KeyboardEvent) => void;

	onMount(() => {
		// Load profile data FIRST, before doing anything else
		const storedProfilePic = sessionStorage.getItem('profilePic') || '';
		username = sessionStorage.getItem('username') || '';

		// Check if the stored profile pic is a real image URL or a generated SVG
		if (storedProfilePic && !storedProfilePic.startsWith('data:image/svg+xml')) {
			// It's a real image URL (like from Google)
			profilePic = storedProfilePic;
		} else if (storedProfilePic) {
			// It's an SVG - use it directly
			profilePic = storedProfilePic;
		} else if (username) {
			// Generate avatar based on username
			const initial = username.charAt(0).toUpperCase();
			profilePic = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><circle cx="14" cy="14" r="14" fill="%232a2e36"/><text x="14" y="19" font-family="Arial" font-size="14" fill="white" text-anchor="middle" font-weight="bold">${initial}</text></svg>`;

			// Store it for future use
			sessionStorage.setItem('profilePic', profilePic);
		} else {
			// No username available, use a more visible question mark
			profilePic = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><circle cx="14" cy="14" r="14" fill="%232a2e36"/><text x="14" y="19" font-family="Arial" font-size="14" fill="white" text-anchor="middle" font-weight="bold">?</text></svg>`;
		}

		// Reset error state
		profilePicError = false;

		// Set up a single menuWidth subscription
		const unsubscribe = menuWidth.subscribe((width) => {
			updateChartWidth();
		});

		if (browser) {
			document.title = 'Atlantis';
			// Set initial state once
			lastSidebarMenu = null;
			menuWidth.set(0);

			updateChartWidth();
			window.addEventListener('resize', updateChartWidth);

			// Define the keydown handler
			keydownHandler = (event: KeyboardEvent) => {
				// Check if input window is active - don't handle keyboard events when input is active
				const inputWindow = document.getElementById('input-window');
				const hiddenInput = document.getElementById('hidden-input');

				// Don't interfere with the input component's keyboard events
				if (inputWindow || hiddenInput === document.activeElement) {
					return;
				}

				// Only handle events when no element is focused or body is focused
				if (!document.activeElement || document.activeElement === document.body) {
					const chartContainer = document.getElementById(`chart_container-0`); // Assuming first chart has ID 0

					if (chartContainer) {
						// Focus the chart container
						chartContainer.focus();

						// Get the native event handlers from the chart container
						const nativeHandlers = (chartContainer as any)._svelte?.events?.keydown;

						if (nativeHandlers) {
							// Call each handler directly with the original event
							nativeHandlers.forEach((handler: Function) => {
								handler.call(chartContainer, event);
							});
						}
					}
				}
			};

			// Add global keyboard event listener
			document.removeEventListener('keydown', keydownHandler); // Remove any existing listener first
			document.addEventListener('keydown', keydownHandler);
		}
		privateRequest<string>('verifyAuth', {}).catch(() => {
			goto('/login');
		});
		initStores();

		dispatchMenuChange.subscribe((menuName: string) => {
			toggleMenu(menuName as Menu);
		});

		// Force profile display to update
		currentProfileDisplay = calculateProfileDisplay();

		// Force refresh of the profile icon
		profileIconKey++;

		// Setup activity listeners
		if (browser) {
			// Use more specific events that indicate user activity
			const activityEvents = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click'];

			// Remove any existing listeners first to avoid duplicates
			activityEvents.forEach((event) => {
				document.removeEventListener(event, resetInactivityTimer);
			});

			// Add the listeners
			activityEvents.forEach((event) => {
				document.addEventListener(event, resetInactivityTimer);
			});

			// Initialize the timer
			resetInactivityTimer();
		}

		// Clean up subscription on component destroy
		return () => {
			unsubscribe();
		};
	});

	onDestroy(() => {
		if (inactivityTimer) {
			clearTimeout(inactivityTimer);
		}

		// Clean up all activity listeners
		if (browser && document) {
			window.removeEventListener('resize', updateChartWidth);
			// Remove global keyboard event listener using the stored handler
			document.removeEventListener('keydown', keydownHandler);
			stopSidebarResize();

			// Clean up all activity listeners
			const activityEvents = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click'];
			activityEvents.forEach((event) => {
				document.removeEventListener(event, resetInactivityTimer);
			});
		}
	});

	function toggleMenu(menuName: Menu) {
		if (menuName === $activeMenu) {
			// If clicking the same menu, close it
			lastSidebarMenu = null;
			menuWidth.set(0);
			changeMenu('none');
		} else {
			// Open new menu
			lastSidebarMenu = null;
			menuWidth.set(300); // Or whatever your default width is
			changeMenu(menuName);
		}

		if (browser) {
			document.title =
				menuName === 'none'
					? 'Atlantis'
					: `${menuName.charAt(0).toUpperCase() + menuName.slice(1)} - Atlantis`;
		}
	}

	// Sidebar resizing
	let resizing = false;
	let minWidth = 200;
	let maxWidth = 600;

	function startResize(event: MouseEvent | TouchEvent) {
		event.preventDefault();
		resizing = true;
		document.addEventListener('mousemove', resize);
		document.addEventListener('mouseup', stopResize);
		document.addEventListener('touchmove', resize);
		document.addEventListener('touchend', stopResize);
		document.body.style.cursor = 'ew-resize';
	}

	function resize(event: MouseEvent | TouchEvent) {
		if (!resizing) return;

		let clientX = 0;
		if (event instanceof MouseEvent) {
			clientX = event.clientX;
		} else {
			clientX = event.touches[0].clientX;
		}

		// Calculate width from right edge of window, excluding the sidebar buttons width
		let newWidth = window.innerWidth - clientX - 60; // 60px is the width of sidebar buttons
		const maxSidebarWidth = Math.min(500, window.innerWidth - 60);

		// Store state before closing
		if (newWidth < minWidth && lastSidebarMenu !== null) {
			lastSidebarMenu = null;
			menuWidth.set(0);
		}
		// Restore state if dragging back
		else if (newWidth >= minWidth && lastSidebarMenu) {
			lastSidebarMenu = lastSidebarMenu;
			menuWidth.set(Math.min(newWidth, maxSidebarWidth));
			lastSidebarMenu = null;
		}
		// Normal resize
		else if (newWidth >= minWidth) {
			// Only update if we're within the maximum width
			menuWidth.set(Math.min(newWidth, maxSidebarWidth));
		}

		// Only update chart width if we're within bounds
		if (newWidth <= maxSidebarWidth) {
			updateChartWidth();
		}
	}

	function stopResize() {
		resizing = false;
		document.removeEventListener('mousemove', resize);
		document.removeEventListener('mouseup', stopResize);
		document.removeEventListener('touchmove', resize);
		document.removeEventListener('touchend', stopResize);
		document.body.style.cursor = 'default';
	}

	// Bottom windows
	function openBottomWindow(type: BottomWindowType) {
		const existing = bottomWindows.find((w) => w.type === type);
		// Close if same window is clicked
		if (existing) {
			bottomWindowsHeight = 0;
			bottomWindows = [];
			return;
		}

		// Preserve current height if another window is already open
		const currentHeight = bottomWindows.length > 0 ? bottomWindowsHeight : 200; // Use default only if no window is open

		// Replace current if a different window is clicked
		bottomWindowsHeight = currentHeight;
		bottomWindows = [
			{
				id: nextWindowId++,
				type,
				x: 0,
				y: 0,
				width: window.innerWidth,
				height: bottomWindowsHeight,
				visible: true
			}
		];
	}

	function minimizeBottomWindow() {
		lastBottomWindow = null; // Clear stored state
		bottomWindowsHeight = 0;
		bottomWindows = [];
	}

	// Draggable logic for popups (if needed)
	let draggingWindowId: number | null = null;
	let offsetX = 0;
	let offsetY = 0;

	function startDrag(event: MouseEvent, windowId: number) {
		draggingWindowId = windowId;
		offsetX = event.offsetX;
		offsetY = event.offsetY;
	}

	function onDrag(event: MouseEvent) {
		if (draggingWindowId === null) return;
		const w = bottomWindows.find((win) => win.id === draggingWindowId);
		if (!w) return;
		w.x = event.clientX - offsetX;
		w.y = event.clientY - offsetY;
		bottomWindows = [...bottomWindows];
	}

	function stopDrag() {
		draggingWindowId = null;
	}

	// Replay controls
	function handlePlay() {
		if (!$streamInfo.replayActive) {
			// Use the new store-based approach
			openInputWindow(['timestamp'], ['timestamp'], { timestamp: 0, extendedHours: false })
				.then((v: Instance) => {
					startReplay(v);
				})
				.catch(() => {});
		} else {
			if ($streamInfo.replayPaused) {
				resumeReplay();
			}
		}
	}

	function handlePause() {
		if ($streamInfo.replayActive && !$streamInfo.replayPaused) {
			pauseReplay();
		}
	}

	function handleStop() {
		stopReplay();
	}

	function handleReset() {
		if ($streamInfo.replayActive) {
			stopReplay();
			startReplay({
				timestamp: $streamInfo.startTimestamp,
				extendedHours: $streamInfo.extendedHours
			});
		}
	}

	function handleNextDay() {
		if ($streamInfo.replayActive) {
			nextDay();
		}
	}

	function handleChangeSpeed(event: Event) {
		const val = parseFloat((event.target as HTMLInputElement).value);
		if (!isNaN(val) && val > 0) {
			changeSpeed(val);
			replaySpeed = val;
		}
	}

	// Settings popup
	let showSettingsPopup = false;
	function toggleSettings() {
		showSettingsPopup = !showSettingsPopup;
	}

	// Bottom resizing
	function startBottomResize(event: MouseEvent) {
		event.preventDefault();
		bottomResizing = true;
		document.addEventListener('mousemove', handleBottomResize);
		document.addEventListener('mouseup', stopBottomResize);
		document.body.style.cursor = 'ns-resize';
	}

	function handleBottomResize(event: MouseEvent) {
		if (!bottomResizing) return;

		// Get container dimensions
		const containerBottom = window.innerHeight - 40; // 40px is bottom-bar height
		const maxWidth = Math.max(window.innerWidth * 0.4, 600); // Reduce to 40% of window width

		// Calculate new height and constrain horizontal position
		const newHeight = containerBottom - event.clientY;
		const newX = Math.min(event.clientX, maxWidth);

		if (newHeight < MIN_BOTTOM_HEIGHT && bottomWindows.length > 0) {
			// Store state before closing
			lastBottomWindow = bottomWindows[0];
			bottomWindowsHeight = 0;
			bottomWindows = [];
		}
		// Restore state if dragging back
		else if (newHeight >= MIN_BOTTOM_HEIGHT && lastBottomWindow) {
			bottomWindowsHeight = newHeight;
			bottomWindows = [
				{
					...lastBottomWindow,
					width: Math.min(window.innerWidth, maxWidth),
					x: Math.min(lastBottomWindow.x, maxWidth - 100) // Ensure handle is always reachable
				}
			];
			lastBottomWindow = null;
		}
		// Normal resize
		else if (newHeight >= MIN_BOTTOM_HEIGHT && newHeight <= MAX_BOTTOM_HEIGHT) {
			bottomWindowsHeight = newHeight;
			// Update window width if it exists
			if (bottomWindows.length > 0) {
				bottomWindows = bottomWindows.map((w) => ({
					...w,
					width: Math.min(window.innerWidth, maxWidth),
					x: Math.min(w.x, maxWidth - 100) // Ensure handle is always reachable
				}));
			}
		}

		updateChartWidth();
	}

	function stopBottomResize() {
		bottomResizing = false;
		document.removeEventListener('mousemove', handleBottomResize);
		document.removeEventListener('mouseup', stopBottomResize);
		document.body.style.cursor = 'default';
	}

	// Add reactive statement for profile display
	$: {
		// Recalculate the profile display whenever these values change
		if (profilePic || username || profilePicError) {
			currentProfileDisplay = calculateProfileDisplay();
		}
	}

	function calculateProfileDisplay() {
		// If profile pic is available and no loading error, use it
		if (profilePic && !profilePicError) {
			return profilePic;
		}

		// If username is available, generate avatar with initial
		if (username) {
			const initial = username.charAt(0).toUpperCase();
			// Use a simpler SVG format to ensure browser compatibility
			const avatar = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><circle cx="14" cy="14" r="14" fill="%232a2e36"/><text x="14" y="19" font-family="Arial" font-size="14" fill="white" text-anchor="middle" font-weight="bold">${initial}</text></svg>`;

			// Update the profilePic value so we don't regenerate each time
			profilePic = avatar;
			if (browser) {
				sessionStorage.setItem('profilePic', avatar);
			}

			return avatar;
		}

		// Fallback if nothing else is available - improved visibility with simpler SVG format
		// Use a simpler SVG format to ensure browser compatibility
		const fallbackAvatar = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><circle cx="14" cy="14" r="14" fill="%232a2e36"/><text x="14" y="19" font-family="Arial" font-size="14" fill="white" text-anchor="middle" font-weight="bold">?</text></svg>`;

		// Store this fallback
		profilePic = fallbackAvatar;

		return fallbackAvatar;
	}

	// Keep the getProfileDisplay function for backward compatibility
	function getProfileDisplay() {
		return currentProfileDisplay;
	}

	function handleProfilePicError() {
		profilePicError = true;

		// Generate a fallback immediately
		if (username) {
			const initial = username.charAt(0).toUpperCase();
			profilePic = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><circle cx="14" cy="14" r="14" fill="%232a2e36"/><text x="14" y="19" font-family="Arial" font-size="14" fill="white" text-anchor="middle" font-weight="bold">${initial}</text></svg>`;
		} else {
			profilePic = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><circle cx="14" cy="14" r="14" fill="%232a2e36"/><text x="14" y="19" font-family="Arial" font-size="14" fill="white" text-anchor="middle" font-weight="bold">?</text></svg>`;
		}

		// Update the stored value with our fallback
		if (browser) {
			sessionStorage.setItem('profilePic', profilePic);
		}

		// Force refresh
		currentProfileDisplay = profilePic;
		profileIconKey++;
	}

	function startSidebarResize(event: MouseEvent | TouchEvent) {
		event.preventDefault();
		sidebarResizing = true;
		document.body.style.cursor = 'ns-resize';
		document.addEventListener('mousemove', handleSidebarResize);
		document.addEventListener('mouseup', stopSidebarResize);
		document.addEventListener('touchmove', handleSidebarResize);
		document.addEventListener('touchend', stopSidebarResize);
	}

	function handleSidebarResize(event: MouseEvent | TouchEvent) {
		if (!sidebarResizing) return;

		let currentY;
		if (event instanceof MouseEvent) {
			currentY = event.clientY;
		} else {
			currentY = event.touches[0].clientY;
		}

		// Account for the bottom bar height (40px) and adjust for the drag handle position
		const bottomBarHeight = 40;
		const newHeight = window.innerHeight - currentY - bottomBarHeight;

		// Clamp the height between min and max values
		tickerHeight = Math.min(Math.max(newHeight, MIN_TICKER_HEIGHT), MAX_TICKER_HEIGHT);

		// Update the CSS variable
		document.documentElement.style.setProperty('--ticker-height', `${tickerHeight}px`);
	}

	function stopSidebarResize() {
		if (!browser) return;

		sidebarResizing = false;
		document.body.style.cursor = '';
		document.removeEventListener('mousemove', handleSidebarResize);
		document.removeEventListener('mouseup', stopSidebarResize);
		document.removeEventListener('touchmove', handleSidebarResize);
		document.removeEventListener('touchend', stopSidebarResize);
	}

	// Add function after other function declarations
	function resetInactivityTimer() {
		if (inactivityTimer) {
			clearTimeout(inactivityTimer);
		}
		if (!screensaverActive) {
			inactivityTimer = setTimeout(() => {
				// Only activate screensaver, don't hide the chart
				screensaverActive = true;
			}, INACTIVITY_TIMEOUT);
		}
	}

	function toggleScreensaver() {
		screensaverActive = !screensaverActive;
		// If turning off screensaver, reset the inactivity timer
		if (!screensaverActive) {
			resetInactivityTimer();
		}
	}

	// Add reactive statements to update the profile icon when data changes
	$: if (profilePic || username) {
		// Increment key to force re-render when profile data changes
		profileIconKey++;
	}

	function handleKeyboardBottomResize(e: KeyboardEvent) {
		if (e.key === 'Enter' || e.key === ' ') {
			e.preventDefault();
			startBottomResize(new MouseEvent('mousedown'));
		}
	}

	function handleKeyboardSidebarResize(e: KeyboardEvent) {
		if (e.key === 'Enter' || e.key === ' ') {
			e.preventDefault();
			startSidebarResize(new MouseEvent('mousedown'));
		}
	}

	function handleKeyboardResize(e: KeyboardEvent) {
		if (e.key === 'Enter' || e.key === ' ') {
			e.preventDefault();
			startResize(new MouseEvent('mousedown'));
		}
	}
</script>

<div
	class="page"
	role="application"
	on:keydown={(e) => {
		if (e.key === 'Escape') {
			minimizeBottomWindow();
		}
	}}
>
	<!-- Global Popups -->
	<Input />
	<RightClick />
	<Setup />
	<Algo />
	<!-- Main area wrapper -->
	<div class="app-container">
		<div class="content-wrapper">
			<!-- Main content area -->
			<div class="main-content">
				<!-- Chart area -->
				<div class="chart-wrapper">
					<ChartContainer width={chartWidth} />
					{#if screensaverActive}
						<Screensaver on:exit={() => (screensaverActive = false)} />
					{/if}
				</div>

				<!-- Bottom windows container -->
				<div class="bottom-windows-container" style="--bottom-height: {bottomWindowsHeight}px">
					{#each bottomWindows as w}
						<div class="bottom-window">
							<div class="window-content">
								{#if w.type === 'screener'}
									<Screener />
								{:else if w.type === 'active'}
									<Active />
								{:else if w.type === 'options'}
									<Options />
								{:else if w.type === 'setups'}
									<Setups />
								{:else if w.type === 'account'}
									<Account />
								{:else if w.type === 'settings'}
									<Settings />
								{:else if w.type === 'newsfeed'}
									<Newsfeed />
								{:else if w.type === 'query'}
									<Query />
								{/if}
							</div>
						</div>
					{/each}
					{#if bottomWindows.length > 0}
						<div
							class="bottom-resize-handle"
							role="separator"
							aria-orientation="horizontal"
							on:mousedown={startBottomResize}
							on:keydown={handleKeyboardBottomResize}
							tabindex="0"
						></div>
					{/if}
				</div>
			</div>

			<!-- Sidebar -->
			{#if $menuWidth > 0}
				<div class="sidebar" style="width: {$menuWidth}px;">
					<div
						class="resize-handle"
						role="separator"
						aria-orientation="vertical"
						on:mousedown={startResize}
						on:touchstart={startResize}
						on:keydown={handleKeyboardResize}
						tabindex="0"
					/>
					<div class="sidebar-content">
						<!-- Main sidebar content -->
						<div class="main-sidebar-content">
							{#if $activeMenu === 'watchlist'}
								<Watchlist />
							{:else if $activeMenu === 'alerts'}
								<Alerts />
							{:else if $activeMenu === 'study'}
								<Study />
							{:else if $activeMenu === 'journal'}
								<Journal />
							{:else if $activeMenu === 'similar'}
								<Similar />
							{/if}
						</div>

						<div
							class="sidebar-resize-handle"
							role="separator"
							aria-orientation="horizontal"
							on:mousedown={startSidebarResize}
							on:touchstart|preventDefault={startSidebarResize}
							on:keydown={handleKeyboardSidebarResize}
							tabindex="0"
						></div>

						<div class="ticker-info-container">
							<Quote />
						</div>
					</div>
				</div>
			{/if}
		</div>

		<!-- Sidebar toggle buttons -->
		<div class="sidebar-buttons">
			{#each sidebarMenus as menu}
				<button
					class="toggle-button side-btn {$activeMenu === menu ? 'active' : ''}"
					on:click={() => toggleMenu(menu)}
					title={menu.charAt(0).toUpperCase() + menu.slice(1)}
				>
					<img src="{menu}.png" alt={menu} class="menu-icon" />
				</button>
			{/each}
		</div>
	</div>

	<!-- Bottom bar -->
	<div class="bottom-bar">
		<div class="bottom-bar-left">
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'screener') ? 'active' : ''}"
				on:click={() => openBottomWindow('screener')}
			>
				Screener
			</button>
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'query') ? 'active' : ''}"
				on:click={() => openBottomWindow('query')}
			>
				Query
			</button>
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'active') ? 'active' : ''}"
				on:click={() => openBottomWindow('active')}
			>
				Active
			</button>
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'options') ? 'active' : ''}"
				on:click={() => openBottomWindow('options')}
			>
				Options
			</button>
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'setups') ? 'active' : ''}"
				on:click={() => openBottomWindow('setups')}
			>
				Setups
			</button>
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'account') ? 'active' : ''}"
				on:click={() => openBottomWindow('account')}
			>
				Account
			</button>
			<button
				class="toggle-button {bottomWindows.some((w) => w.type === 'newsfeed') ? 'active' : ''}"
				on:click={() => openBottomWindow('newsfeed')}
			>
				News
			</button>
		</div>

		<div class="bottom-bar-right">
			<!-- Combined replay button -->
			<button
				on:click={() => {
					if (!$streamInfo.replayActive) {
						handlePlay();
					} else if ($streamInfo.replayPaused) {
						handlePlay();
					} else {
						handlePause();
					}
				}}
			>
				{#if !$streamInfo.replayActive}
					Replay
				{:else if $streamInfo.replayPaused}
					Play
				{:else}
					Pause
				{/if}
			</button>

			{#if $streamInfo.replayActive}
				<button on:click={handleStop}>Stop</button>
				<button on:click={handleReset}>Reset</button>
				<button on:click={handleNextDay}>Next Day</button>

				<label class="speed-label">
					Speed:
					<input
						type="number"
						step="0.1"
						min="0.1"
						value={replaySpeed}
						on:input={handleChangeSpeed}
						class="speed-input"
					/>
				</label>
			{/if}

			<!-- Current timestamp -->
			<span class="value">
				{#if $streamInfo.timestamp !== undefined}
					{formatTimestamp($streamInfo.timestamp)}
				{:else}
					Loading Time...
				{/if}
			</span>

			<button
				class="toggle-button {screensaverActive ? 'active' : ''}"
				on:click={toggleScreensaver}
				title="Screensaver"
			>
				<i class="fas fa-tv"></i>
			</button>

			<button class="profile-button" on:click={toggleSettings} aria-label="Toggle Settings">
				<!-- Add key to force re-render when the profile changes -->
				{#key profileIconKey}
					<img
						src={getProfileDisplay()}
						alt="Profile"
						class="pfp"
						on:error={handleProfilePicError}
					/>
				{/key}
			</button>
		</div>
	</div>

	{#if showSettingsPopup}
		<div
			class="settings-overlay"
			role="dialog"
			aria-label="Settings"
			on:click|self={toggleSettings}
			on:keydown={(e) => {
				if (e.key === 'Escape') {
					toggleSettings();
				}
			}}
		>
			<div class="settings-modal">
				<div class="settings-header">
					<h2>Settings</h2>
					<button class="close-btn" on:click={toggleSettings}>Ã—</button>
				</div>
				<div class="settings-content">
					<Settings />
				</div>
			</div>
		</div>
	{/if}
</div>

<!--/+page.svelte-->

<!--/+page.svelte-->

<!--/+page.svelte-->

<style>
	.page {
		width: 100vw;
		height: 100vh;
		position: relative;
		display: flex;
		flex-direction: column;
		overflow: hidden;
		background-color: var(--c1);
		margin: 0;
		padding: 0;
	}

	.content-wrapper {
		flex: 1;
		display: flex;
		height: 100%;
		min-height: 0;
		position: relative;
		margin-right: 60px;
	}

	.main-content {
		flex: 1;
		display: flex;
		flex-direction: column;
		position: relative;
		overflow: hidden;
		min-height: 0;
	}

	.bottom-bar {
		height: 40px;
		min-height: 40px;
		background-color: var(--c2);
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0 10px;
		gap: 10px;
		flex-shrink: 0;
		width: 100%;
		z-index: 3;
		border-top: 1px solid var(--c1);
	}

	.chart-wrapper {
		flex: 1;
		position: relative;
		overflow: hidden;
		min-height: 0;
	}

	.sidebar {
		height: 100%;
		background-color: var(--ui-bg-primary);
		display: flex;
		flex-direction: column;
		position: relative;
		flex-shrink: 0;
		border-left: 1px solid var(--ui-border);
		max-width: min(500px, calc(100vw - 60px)); /* Reduce max width to 500px */
	}

	.sidebar-buttons {
		position: fixed;
		top: 0;
		right: 0;
		height: 100vh;
		width: 60px;
		display: flex;
		flex-direction: column;
		background-color: var(--c2);
		z-index: 2;
		flex-shrink: 0;
		border-left: 1px solid var(--c4);
	}

	.resize-handle {
		width: 4px;
		height: 100%;
		cursor: ew-resize;
		background-color: var(--c4);
		flex-shrink: 0;
		transition: background-color 0.2s;
		position: absolute;
		left: -4px;
		top: 0;
		z-index: 100;
		overflow: hidden;
		font-size: 0;
		line-height: 0;
		text-indent: -9999px;
	}

	.resize-handle:hover {
		background-color: var(--c3);
	}

	.side-btn {
		flex: 0 0 60px;
	}

	.menu-icon {
		width: 24px;
		height: 24px;
		object-fit: contain;
	}

	.bottom-bar-left {
		display: flex;
		align-items: center;
		gap: 8px;
	}

	.bottom-bar-right {
		display: flex;
		align-items: center;
		gap: 12px;
		margin-left: auto;
	}

	.bottom-bar .pfp {
		width: 28px;
		height: 28px;
		border-radius: 50%;
		cursor: pointer;
		margin-left: 8px;
		background-color: var(--c3);
		border: 1px solid var(--c4);
		overflow: hidden;
		display: block;
	}

	.speed-label {
		display: flex;
		align-items: center;
		color: #fff;
		font-size: 0.9em;
	}

	.speed-input {
		width: 50px;
		margin-left: 5px;
		height: 24px;
		background: var(--c1);
		border: 1px solid var(--c3);
		color: #fff;
		border-radius: 3px;
		padding: 0 4px;
	}

	.draggable-window {
		position: fixed;
		border: 1px solid var(--c2);
		background-color: var(--c1);
		z-index: 999;
		min-width: 200px;
		min-height: 100px;
		box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
		overflow: hidden;
	}

	.window-header {
		background-color: var(--c2);
		color: #fff;
		padding: 5px;
		display: flex;
		justify-content: space-between;
		cursor: move;
	}

	.window-title {
		font-weight: bold;
	}

	.close-btn {
		background: transparent;
		border: none;
		color: #fff;
		cursor: pointer;
	}

	.window-content {
		padding: 10px;
		background-color: var(--ui-bg-primary);
		height: calc(100% - 30px);
		overflow-y: auto;
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	.window-content::-webkit-scrollbar {
		display: none;
	}

	:global(body) {
		margin: 0;
		padding: 0;
		overflow: hidden;
	}

	:global(*) {
		box-sizing: border-box;
	}

	.bottom-windows-container {
		position: relative;
		height: var(--bottom-height);
		background: var(--c1);
		border-top: 1px solid var(--c4);
		overflow: hidden;
		display: flex;
		border-top: none;
		max-width: 100%; /* Ensure container doesn't overflow */
	}

	.bottom-window {
		width: 100%;
		height: 100%;
		display: flex;
		flex-direction: column;
		background: var(--ui-bg-primary);
		min-width: 0; /* Allow window to shrink */
	}

	.window-content {
		flex: 1;
		overflow-y: auto;
		overflow-x: hidden; /* Prevent horizontal overflow */
		padding: 8px;
		scrollbar-width: none;
		height: 100%;
		background: var(--ui-bg-primary);
		min-width: 0; /* Allow content to shrink */
	}

	.bottom-resize-handle {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 4px;
		background: var(--c4);
		cursor: ns-resize;
		z-index: 100;
		transition: background-color 0.2s;
	}

	.bottom-resize-handle:hover {
		background: var(--c3);
	}

	.sidebar-content {
		flex: 1;
		display: flex;
		flex-direction: column;
		overflow: hidden;
		height: 100%;
	}

	.main-sidebar-content {
		flex: 1;
		overflow-y: auto;
		scrollbar-width: none;
		min-height: 0;
	}

	.ticker-info-container {
		flex-shrink: 0;
		border-top: 1px solid var(--c3);
		background: var(--c2);
		height: var(--ticker-height);
		overflow-y: auto;
		overflow-x: hidden;
	}

	.main-sidebar-content::-webkit-scrollbar,
	.sidebar-content::-webkit-scrollbar {
		display: none;
	}

	.settings-overlay {
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background-color: rgba(0, 0, 0, 0.7);
		display: flex;
		justify-content: center;
		align-items: center;
		z-index: 1000;
	}

	.settings-modal {
		width: 50%;
		height: 50%;
		background-color: var(--c1);
		border-radius: 8px;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
		display: flex;
		flex-direction: column;
		overflow: hidden;
	}

	.settings-header {
		background-color: var(--c2);
		padding: 12px 16px;
		display: flex;
		justify-content: space-between;
		align-items: center;
		border-bottom: 1px solid var(--c3);
	}

	.settings-header h2 {
		margin: 0;
		color: var(--f1);
		font-size: 1.2em;
	}

	.settings-header .close-btn {
		background: none;
		border: none;
		color: var(--f1);
		font-size: 1.5em;
		cursor: pointer;
		padding: 0 4px;
		line-height: 1;
	}

	.settings-header .close-btn:hover {
		color: var(--f2);
	}

	.settings-content {
		flex: 1;
		overflow-y: auto;
		padding: 16px;
	}

	/* Prevent text-selection while dragging */
	.bottom-bar,
	.bottom-bar button,
	.side-btn,
	.menu-icon,
	.pfp,
	.close-btn,
	.speed-label {
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		user-select: none;
	}

	.sidebar-resize-handle {
		height: 4px;
		background: var(--c4);
		cursor: ns-resize;
		margin: -2px 0;
		z-index: 10;
		position: relative;
		transition: background-color 0.2s;
	}

	.sidebar-resize-handle:hover {
		background: var(--c3);
	}

	.screensaver-overlay {
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background-color: var(--c1);
		z-index: 1000;
		cursor: pointer;
		border: none;
		padding: 0;
		width: 100%;
		height: 100%;
	}

	.profile-button {
		background: none;
		border: none;
		padding: 0;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
	}
</style>

```

```chart/chart.svelte
<file>/home/aj/dev/study/services/frontend/src/lib/features/chart/chart.svelte</file>
<!-- chart.svelte-->
<script lang="ts">
	import Legend from './legend.svelte';
	import Shift from './shift.svelte';
	import DrawingMenu from './drawingMenu.svelte';
	import { privateRequest } from '$lib/core/backend';
	import { type DrawingMenuProps, addHorizontalLine, drawingMenuProps } from './drawingMenu.svelte';
	import type { Instance as CoreInstance, TradeData, QuoteData } from '$lib/core/types';
	import {
		setActiveChart,
		chartQueryDispatcher,
		chartEventDispatcher,
		queryChart
	} from './interface';
	import { streamInfo, settings, activeAlerts } from '$lib/core/stores';
	import type { ShiftOverlay, ChartEventDispatch, BarData, ChartQueryDispatch } from './interface';
	import { queryInstanceInput } from '$lib/utils/popups/input.svelte';
	import { queryInstanceRightClick } from '$lib/utils/popups/rightClick.svelte';
	import { createChart, ColorType, CrosshairMode } from 'lightweight-charts';
	import type {
		IChartApi,
		ISeriesApi,
		CandlestickData,
		Time,
		WhitespaceData,
		CandlestickSeriesOptions,
		DeepPartial,
		CandlestickStyleOptions,
		CustomSeriesOptions,
		SeriesOptionsCommon,
		UTCTimestamp,
		HistogramStyleOptions,
		HistogramData,
		HistogramSeriesOptions,
		LineStyleOptions,
		LineWidth
	} from 'lightweight-charts';
	import {
		calculateRVOL,
		calculateSingleADR,
		calculateVWAP,
		calculateMultipleSMAs
	} from './indicators';
	import type { Writable } from 'svelte/store';
	import { writable, get } from 'svelte/store';
	import { onMount } from 'svelte';
	import {
		UTCSecondstoESTSeconds,
		ESTSecondstoUTCSeconds,
		ESTSecondstoUTCMillis,
		getReferenceStartTimeForDateMilliseconds,
		timeframeToSeconds
	} from '$lib/core/timestamp';
	import { addStream } from '$lib/utils/stream/interface';
	import { ArrowMarkersPaneView, type ArrowMarker } from './arrowMarkers';
	import { EventMarkersPaneView, type EventMarker } from './eventMarkers';
	import { adjustEventsToTradingDays, handleScreenshot } from './chartHelpers';
	import { SessionHighlighting, createDefaultSessionHighlighter } from './sessionShade';

	interface EventValue {
		type?: string;
		url?: string;
		ratio?: string;
		amount?: string;
		exDate?: string;
		payDate?: string;
	}

	interface Trade {
		time: number;
		type: string;
		price: number;
	}

	interface Instance extends CoreInstance {
		securityId: number;
		chartId?: number;
		bars?: number;
		extendedHours?: boolean;
	}

	interface ExtendedInstance extends Instance {
		extendedHours?: boolean;
		inputString?: string;
	}

	interface ChartInstance extends ExtendedInstance {
		bars?: number;
		direction?: 'forward' | 'backward';
		requestType?: 'loadNewTicker' | 'loadAdditionalData';
		includeLastBar?: boolean;
		ticker: string;
		timestamp: number;
		timeframe: string;
		securityId: number;
		price: number;
	}

	let bidLine: any;
	let askLine: any;
	let currentBarTimestamp: number;

	let chartCandleSeries: ISeriesApi<
		'Candlestick',
		Time,
		WhitespaceData<Time> | CandlestickData<Time>,
		CandlestickSeriesOptions,
		DeepPartial<CandlestickStyleOptions & SeriesOptionsCommon>
	>;
	let chartVolumeSeries: ISeriesApi<
		'Histogram',
		Time,
		WhitespaceData<Time> | HistogramData<Time>,
		HistogramSeriesOptions,
		DeepPartial<HistogramStyleOptions & SeriesOptionsCommon>
	>;
	let sma10Series: ISeriesApi<
		'Line',
		Time,
		WhitespaceData<Time> | { time: UTCTimestamp; value: number },
		any,
		any
	>;
	let sma20Series: ISeriesApi<
		'Line',
		Time,
		WhitespaceData<Time> | { time: UTCTimestamp; value: number },
		any,
		any
	>;
	let vwapSeries: ISeriesApi<
		'Line',
		Time,
		WhitespaceData<Time> | { time: UTCTimestamp; value: number },
		any,
		any
	>;
	let chart: IChartApi;
	let latestCrosshairPositionTime: number;
	let latestCrosshairPositionY = 0;
	let chartEarliestDataReached = false;
	let chartLatestDataReached = false;
	let isLoadingChartData = false;
	let lastChartQueryDispatchTime = 0;
	let queuedLoad: Function | null = null;
	let shiftDown = false;
	const chartRequestThrottleDuration = 150;
	const bufferInScreenSizes = 2;
	const defaultBarsOnScreen = 100;
	const defaultHoveredCandleData = {
		rvol: 0,
		open: 0,
		high: 0,
		low: 0,
		close: 0,
		volume: 0,
		adr: 0,
		chg: 0,
		chgprct: 0
	};
	const hoveredCandleData = writable(defaultHoveredCandleData);
	const shiftOverlay: Writable<ShiftOverlay> = writable({
		x: 0,
		y: 0,
		startX: 0,
		startY: 0,
		width: 0,
		height: 0,
		isActive: false,
		startPrice: 0,
		currentPrice: 0
	});
	export let chartId: number;
	export let width: number;
	let chartSecurityId: number;
	let chartTimeframe: string;
	let chartTimeframeInSeconds: number;
	let chartExtendedHours: boolean;
	let releaseFast: () => void = () => {};
	let releaseQuote: () => void = () => {};
	let currentChartInstance: ChartInstance = {
		ticker: '',
		timestamp: 0,
		timeframe: '',
		securityId: 0,
		price: 0,
		extendedHours: false
	};
	let blockingChartQueryDispatch = {};
	let isPanning = false;
	const excludedConditions = new Set([2, 7, 10, 13, 15, 16, 20, 21, 22, 29, 33, 37]);
	let mouseDownStartX = 0;
	let mouseDownStartY = 0;
	const DRAG_THRESHOLD = 3; // pixels of movement before considered a drag

	// Add new interface for alert lines
	interface AlertLine {
		price: number;
		line: any; // Use any for now since we don't have the full IPriceLine type
		alertId: number;
	}

	// Add new property to track alert lines
	let alertLines: AlertLine[] = [];

	let arrowSeries: any = null; // Initialize as null
	let eventSeries: ISeriesApi<'Custom', Time, EventMarker>;
	let eventMarkerView: EventMarkersPaneView;
	let selectedEvent: {
		events: EventMarker['events'];
		x: number;
		y: number;
	} | null = null;
	let hoveredEvent: {
		events: EventMarker['events'];
		x: number;
		y: number;
	} | null = null;

	let sessionHighlighting: SessionHighlighting;

	// Add throttling variables for chart updates
	let pendingBarUpdate: any = null;
	let pendingVolumeUpdate: any = null;
	let lastUpdateTime = 0;
	const updateThrottleMs = 100;

	let keyBuffer: string[] = []; // This is for catching key presses from the keyboard before the input system is active 
	let isInputActive = false;    // Track if input window is active/initializing

	// Add type definitions at the top
	interface Alert {
		alertType: string;
		alertPrice?: number;
		securityId: string | number;
		alertId: number;
	}

	interface IPriceLine {
		price: number;
		color: string;
		lineWidth: number;
		lineStyle: number;
		axisLabelVisible: boolean;
		title: string;
	}

	interface HorizontalLine {
		id: number;
		price: number;
		line: IPriceLine;
		color: string;
		lineWidth: number;
		amount?: number;
	}

	interface ScreenshotOptions {
		type: string;
		url: string;
		ratio: number;
	}

	type StreamReleaseFunction = () => void;

	function extendedHours(timestamp: number): boolean {
		const date = new Date(timestamp);
		const minutes = date.getHours() * 60 + date.getMinutes();
		return minutes < 570 || minutes >= 960; // 9:30 AM - 4:00 PM EST
	}

	function backendLoadChartData(inst: ChartQueryDispatch): void {
		console.log(inst);
		eventSeries.setData([]);
		if (inst.requestType === 'loadNewTicker') {
			bidLine.setData([]);
			askLine.setData([]);
			arrowSeries.setData([]);
		}
		if (isLoadingChartData || !inst.ticker || !inst.timeframe || !inst.securityId) {
			return;
		}
		isLoadingChartData = true;
		lastChartQueryDispatchTime = Date.now();
		if (
			$streamInfo.replayActive &&
			(inst.timestamp == 0 || (inst.timestamp ?? 0) > $streamInfo.timestamp)
		) {
			('adjusting to stream timestamp');
			inst.timestamp = Math.floor($streamInfo.timestamp);
		}
		inst;
		inst.extendedHours;
		privateRequest<{ bars: BarData[]; isEarliestData: boolean }>('getChartData', {
			securityId: inst.securityId,
			timeframe: inst.timeframe,
			timestamp: inst.timestamp,
			direction: inst.direction,
			bars: inst.bars,
			extendedhours: inst.extendedHours,
			isreplay: $streamInfo.replayActive
		})
			.then((response) => {
				const barDataList = response.bars;
				console.log(response);
				blockingChartQueryDispatch = inst;
				if (!(Array.isArray(barDataList) && barDataList.length > 0)) {
					return;
				}
				let newCandleData = barDataList.map((bar) => ({
					time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp,
					open: bar.open,
					high: bar.high,
					low: bar.low,
					close: bar.close
				}));
				let newVolumeData: any;
				if (get(settings).dolvol) {
					newVolumeData = barDataList.map((bar) => ({
						time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp,
						value: (bar.volume * (bar.close + bar.open)) / 2,
						color: bar.close > bar.open ? '#089981' : '#ef5350'
					}));
				} else {
					newVolumeData = barDataList.map((bar) => ({
						time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp,
						value: bar.volume,
						color: bar.close > bar.open ? '#089981' : '#ef5350'
					}));
				}
				if (inst.requestType === 'loadAdditionalData' && inst.direction === 'backward') {
					const earliestCandleTime = chartCandleSeries.data()[0]?.time;
					if (
						typeof earliestCandleTime === 'number' &&
						newCandleData[newCandleData.length - 1].time <= earliestCandleTime
					) {
						newCandleData = [...newCandleData.slice(0, -1), ...chartCandleSeries.data()] as any;
						newVolumeData = [...newVolumeData.slice(0, -1), ...chartVolumeSeries.data()] as any;
					}
				} else if (inst.requestType === 'loadAdditionalData') {
					const latestCandleTime =
						chartCandleSeries.data()[chartCandleSeries.data().length - 1]?.time;
					if (typeof latestCandleTime === 'number' && newCandleData[0].time >= latestCandleTime) {
						newCandleData = [...chartCandleSeries.data(), ...newCandleData.slice(1)] as any;
						newVolumeData = [...chartVolumeSeries.data(), ...newVolumeData.slice(1)] as any;
					}
				} else if (inst.requestType === 'loadNewTicker') {
					if (inst.includeLastBar == false && !$streamInfo.replayActive) {
						newCandleData = newCandleData.slice(0, newCandleData.length - 1);
						newVolumeData = newVolumeData.slice(0, newVolumeData.length - 1);
					}
					releaseFast();
					releaseQuote();
					/*privateRequest<number>('getMarketCap', { ticker: inst.ticker }).then(
						(res: { marketCap: number }) => {
							hoveredCandleData.update((v: typeof defaultHoveredCandleData) => {
								v.mcap = res.marketCap;
								return v;
							});
						}
					);*/
					drawingMenuProps.update((v) => ({
						...v,
						chartCandleSeries: chartCandleSeries,
						securityId: Number(inst.securityId)
					}));
					for (const line of $drawingMenuProps.horizontalLines) {
						chartCandleSeries.removePriceLine(line.line);
					}
					privateRequest<HorizontalLine[]>('getHorizontalLines', {
						securityId: inst.securityId
					}).then((res: HorizontalLine[]) => {
						if (res !== null && res.length > 0) {
							for (const line of res) {
								addHorizontalLine(
									line.price,
									currentChartInstance.securityId,
									line.id,
									line.color || '#FFFFFF',
									(line.lineWidth || 1) as LineWidth
								);
							}
						}
					});
				}

				// Check if we reach end of avaliable data
				if (inst.timestamp == 0) {
					chartLatestDataReached = true;
				}
				if (barDataList.length < (inst.bars ?? 0)) {
					if (inst.direction == 'backward') {
						chartEarliestDataReached = response.isEarliestData;
					} else if (inst.direction == 'forward') {
						('chartLatestDataReached');
						chartLatestDataReached = true;
					}
				}
				queuedLoad = () => {
					// Add SEC filings request when loading new ticker
					try {
						const bars = chartCandleSeries.data();
						if (bars.length > 0) {
							const firstBar = bars[0];
							const lastBar = bars[bars.length - 1];

							const fromTime = ESTSecondstoUTCMillis(firstBar.time as UTCTimestamp) as number;
							const toTime = ESTSecondstoUTCMillis(lastBar.time as UTCTimestamp) as number;

							privateRequest<any[]>('getChartEvents', {
								securityId: inst.securityId,
								from: fromTime,
								to: toTime,
								includeSECFilings: get(settings).showFilings
							}).then((events) => {
								// Check if events is empty or undefined
								if (!events || events.length === 0) {
									// Clear any existing events data
									eventSeries.setData([]);
									return; // Exit early
								}

								const eventsByTime = new Map<
									number,
									Array<{
										type: string;
										title: string;
										url?: string;
										value?: string;
										exDate?: string;
										payoutDate?: string;
									}>
								>();

								events.forEach((event) => {
									// Convert timestamp from UTC milliseconds to EST seconds
									event.timestamp = UTCSecondstoESTSeconds(event.timestamp / 1000) as UTCTimestamp;

									// Round to the nearest timeframe
									const roundedTime =
										Math.floor(event.timestamp / chartTimeframeInSeconds) * chartTimeframeInSeconds;

									if (!eventsByTime.has(roundedTime)) {
										eventsByTime.set(roundedTime, []);
									}

									// Parse the JSON string into an object
									let valueObj: EventValue = {};
									try {
										valueObj = JSON.parse(event.value);
									} catch (e) {
										console.error('Failed to parse event value:', e, event.value);
									}

									// Create proper event object based on type
									if (event.type === 'sec_filing') {
										eventsByTime.get(roundedTime)?.push({
											type: 'sec_filing',
											title: valueObj.type || 'SEC Filing',
											url: valueObj.url
										});
									} else if (event.type === 'split') {
										eventsByTime.get(roundedTime)?.push({
											type: 'split',
											title: `Split: ${valueObj.ratio || 'unknown'}`,
											value: valueObj.ratio
										});
									} else if (event.type === 'dividend') {
										const amount = typeof valueObj.amount === 'string' ? valueObj.amount : '0.00';
										eventsByTime.get(roundedTime)?.push({
											type: 'dividend',
											title: `Dividend: $${amount}`,
											value: amount,
											exDate: valueObj.exDate || 'Unknown',
											payoutDate: valueObj.payDate || 'Unknown'
										});
									}
								});

								// Fix the event data handling
								let eventData: EventMarker[] = [];
								eventsByTime.forEach((events, time) => {
									eventData.push({
										time: time as UTCTimestamp,
										events: events
									});
								});

								// Cast the data array to any to avoid readonly issues
								eventData = adjustEventsToTradingDays(eventData, [...chartCandleSeries.data()]);

								// Set the data on the event markers series
								eventSeries.setData(eventData);
							});
						}
					} catch (error) {
						console.warn('Failed to fetch chart events:', error);
					}

					if (inst.direction == 'forward') {
						const visibleRange = chart.timeScale().getVisibleRange();
						const vrFrom = visibleRange?.from;
						const vrTo = visibleRange?.to;

						// Only set visible range if both from and to values are valid
						chartCandleSeries.setData(newCandleData);
						chartVolumeSeries.setData(newVolumeData);
						if (vrFrom && vrTo && typeof vrFrom === 'number' && typeof vrTo === 'number') {
							chart.timeScale().setVisibleRange({
								from: vrFrom,
								to: vrTo
							});
						}
					} else if (inst.direction == 'backward') {
						chartCandleSeries.setData(newCandleData);
						chartVolumeSeries.setData(newVolumeData);
						if (
							arrowSeries &&
							inst &&
							typeof inst === 'object' &&
							'trades' in inst &&
							Array.isArray(inst.trades)
						) {
							const markersByTime = new Map<
								number,
								{
									entries: Array<{ price: number; isLong: boolean }>;
									exits: Array<{ price: number; isLong: boolean }>;
								}
							>();

							// Process all trades
							inst.trades.forEach((trade: Trade) => {
								const tradeTime = UTCSecondstoESTSeconds(trade.time / 1000);
								const roundedTime =
									Math.floor(tradeTime / chartTimeframeInSeconds) * chartTimeframeInSeconds;

								if (!markersByTime.has(roundedTime)) {
									markersByTime.set(roundedTime, { entries: [], exits: [] });
								}

								// Determine if this is an entry or exit based on trade type
								const isEntry = trade.type === 'Buy' || trade.type === 'Short';
								const isLong = trade.type === 'Buy' || trade.type === 'Sell';

								if (isEntry) {
									markersByTime.get(roundedTime)?.entries.push({
										price: trade.price,
										isLong: isLong
									});
								} else {
									markersByTime.get(roundedTime)?.exits.push({
										price: trade.price,
										isLong: isLong
									});
								}
							});

							// Convert to format for ArrowMarkersPaneView
							const markers = Array.from(markersByTime.entries()).map(([time, data]) => ({
								time: time as UTCTimestamp,
								entries: data.entries,
								exits: data.exits
							}));
							// Sort markers by timestamp (time) in ascending order
							markers.sort((a, b) => a.time - b.time);
							arrowSeries.setData(markers);
						}
					}
					queuedLoad = null;

					// Fix the SMA data type issues
					const smaResults = calculateMultipleSMAs(newCandleData, [10, 20]);
					const sma10Data = smaResults.get(10);
					const sma20Data = smaResults.get(20);

					if (sma10Data) {
						sma10Series.setData([...sma10Data] as Array<
							WhitespaceData<Time> | { time: UTCTimestamp; value: number }
						>);
					}
					if (sma20Data) {
						sma20Series.setData([...sma20Data] as Array<
							WhitespaceData<Time> | { time: UTCTimestamp; value: number }
						>);
					}

					if (/^\d+$/.test(inst.timeframe ?? '')) {
						vwapSeries.setData(calculateVWAP(newCandleData, newVolumeData));
					} else {
						vwapSeries.setData([]);
					}
					if (inst.requestType == 'loadNewTicker') {
						chart.timeScale().resetTimeScale();
						//chart.timeScale().fitContent();
						if (currentChartInstance.timestamp === 0) {
							chart.timeScale().applyOptions({
								rightOffset: 10
							});
						} else {
							chart.timeScale().applyOptions({
								rightOffset: 0
							});
						}
						releaseFast = addStream(inst, 'all', updateLatestChartBar) as () => void;
						releaseQuote = addStream(inst, 'quote', updateLatestQuote) as () => void;
					}
					isLoadingChartData = false; // Ensure this runs after data is loaded
				};
				if (
					inst.direction == 'backward' ||
					inst.requestType == 'loadNewTicker' ||
					(inst.direction == 'forward' && !isPanning)
				) {
					queuedLoad();
					if (
						inst.requestType === 'loadNewTicker' &&
						!chartLatestDataReached &&
						!$streamInfo.replayActive
					) {
						('1');
						backendLoadChartData({
							...currentChartInstance,
							timestamp: ESTSecondstoUTCMillis(
								chartCandleSeries.data()[chartCandleSeries.data().length - 1].time as UTCTimestamp
							) as UTCTimestamp,
							bars: 150, //+ 2*Math.floor(chart.getLogicalRange.to) - chartCandleSeries.data().length,
							direction: 'forward',
							requestType: 'loadAdditionalData',
							includeLastBar: true
						});
					}
				}
			})
			.catch((error: string) => {
				console.error(error);

				isLoadingChartData = false; // Ensure this runs after data is loaded
			});
	}
	function updateLatestQuote(data: QuoteData) {
		if (!data?.bidPrice || !data?.askPrice) {
			return;
		}
		const candle = chartCandleSeries.data().at(-1);
		if (!candle) return;
		const time = candle.time;
		bidLine.setData([{ time: time, value: data.bidPrice }]);
		askLine.setData([{ time: time, value: data.askPrice }]);
	}
	// Create a horizontal line at the current crosshair position (Y-coordinate)

	function handleMouseMove(event: MouseEvent) {
		if (!chartCandleSeries || !$drawingMenuProps.isDragging || !$drawingMenuProps.selectedLine)
			return;

		const price = chartCandleSeries.coordinateToPrice(event.clientY);
		if (typeof price !== 'number' || price <= 0) return;

		// Update the line position visually
		$drawingMenuProps.selectedLine.applyOptions({
			price: price,
			title: `Price: ${price.toFixed(2)}`
		});

		// Update the stored price in horizontalLines array
		const lineIndex = $drawingMenuProps.horizontalLines.findIndex(
			(line) => line.line === $drawingMenuProps.selectedLine
		);
		if (lineIndex !== -1) {
			$drawingMenuProps.horizontalLines[lineIndex].price = price;
		}
	}

	function handleMouseUp() {
		if (!$drawingMenuProps.isDragging || !$drawingMenuProps.selectedLine) return;

		const lineData = $drawingMenuProps.horizontalLines.find(
			(line) => line.line === $drawingMenuProps.selectedLine
		);

		if (lineData) {
			// Update line position in backend
			privateRequest<void>(
				'updateHorizontalLine',
				{
					id: lineData.id,
					price: lineData.price,
					securityId: chartSecurityId
				},
				true
			);
		}

		drawingMenuProps.update((v) => ({ ...v, isDragging: false }));
		document.removeEventListener('mousemove', handleMouseMove);
		document.removeEventListener('mouseup', handleMouseUp);
	}

	function startDragging(event: MouseEvent) {
		if (!$drawingMenuProps.selectedLine) return;

		event.preventDefault();
		event.stopPropagation();

		drawingMenuProps.update((v) => ({ ...v, isDragging: true }));
		document.addEventListener('mousemove', handleMouseMove);
		document.addEventListener('mouseup', handleMouseUp);
	}

	function determineClickedLine(event: MouseEvent) {
		const mouseY = event.clientY;
		const pixelBuffer = 5;

		const upperPrice = chartCandleSeries.coordinateToPrice(mouseY - pixelBuffer) || 0;
		const lowerPrice = chartCandleSeries.coordinateToPrice(mouseY + pixelBuffer) || 0;

		if (upperPrice == 0 || lowerPrice == 0) return false;

		// Only check regular horizontal lines, not alert lines
		for (const line of $drawingMenuProps.horizontalLines) {
			if (line.price <= upperPrice && line.price >= lowerPrice) {
				drawingMenuProps.update((v: DrawingMenuProps) => ({
					...v,
					chartCandleSeries: chartCandleSeries,
					selectedLine: line.line,
					selectedLinePrice: line.price,
					clientX: event.clientX,
					clientY: event.clientY,
					active: false,
					selectedLineId: line.id
				}));

				event.preventDefault();
				event.stopPropagation();
				return true;
			}
		}

		setTimeout(() => {
			drawingMenuProps.update((v: DrawingMenuProps) => ({
				...v,
				selectedLine: null,
				selectedLineId: -1,
				active: false
			}));
		}, 100);
		return false;
	}

	function handleMouseDown(event: MouseEvent) {
		if (determineClickedLine(event)) {
			('determineClickedLine');
			mouseDownStartX = event.clientX;
			mouseDownStartY = event.clientY;

			// Add mousemove listener to detect drag
			const handleMouseMoveForDrag = (moveEvent: MouseEvent) => {
				const deltaX = Math.abs(moveEvent.clientX - mouseDownStartX);
				const deltaY = Math.abs(moveEvent.clientY - mouseDownStartY);

				if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
					// It's a drag - start dragging and remove this temporary listener
					document.removeEventListener('mousemove', handleMouseMoveForDrag);
					document.removeEventListener('mouseup', handleMouseUpForClick);
					startDragging(moveEvent);
				}
			};

			// Add mouseup listener to handle click
			const handleMouseUpForClick = (upEvent: MouseEvent) => {
				const deltaX = Math.abs(upEvent.clientX - mouseDownStartX);
				const deltaY = Math.abs(upEvent.clientY - mouseDownStartY);

				if (deltaX <= DRAG_THRESHOLD && deltaY <= DRAG_THRESHOLD) {
					('click');
					// It's a click - show menu
					drawingMenuProps.update((v) => ({
						...v,
						active: true,
						clientX: upEvent.clientX,
						clientY: upEvent.clientY
					}));
				}

				// Clean up listeners
				document.removeEventListener('mousemove', handleMouseMoveForDrag);
				document.removeEventListener('mouseup', handleMouseUpForClick);
			};

			document.addEventListener('mousemove', handleMouseMoveForDrag);
			document.addEventListener('mouseup', handleMouseUpForClick);
			return;
		}

		setActiveChart(chartId, currentChartInstance);
		isPanning = true;
		if (shiftDown || get(shiftOverlay).isActive) {
			shiftOverlay.update((v: ShiftOverlay): ShiftOverlay => {
				v.isActive = !v.isActive;
				if (v.isActive) {
					v.startX = event.clientX;
					v.startY = event.clientY;
					v.width = 0;
					v.height = 0;
					v.x = v.startX;
					v.y = v.startY;
					v.startPrice = chartCandleSeries.coordinateToPrice(v.startY) || 0;
					document.addEventListener('mousemove', shiftOverlayTrack);
					document.addEventListener('mouseup', handleShiftOverlayEnd);
				} else {
					document.removeEventListener('mousemove', shiftOverlayTrack);
				}
				return v;
			});
		}
	}

	function shiftOverlayTrack(event: MouseEvent): void {
		shiftOverlay.update((v: ShiftOverlay): ShiftOverlay => {
			const god = {
				...v,
				width: Math.abs(event.clientX - v.startX),
				height: Math.abs(event.clientY - v.startY),
				x: Math.min(event.clientX, v.startX),
				y: Math.min(event.clientY, v.startY),
				currentPrice: chartCandleSeries.coordinateToPrice(event.clientY) || 0
			};
			return god;
		});
	}

	async function updateLatestChartBar(trade: TradeData) {
		// Early returns for invalid data
		if (
			!trade?.price ||
			!trade?.size ||
			!trade?.timestamp ||
			!chartCandleSeries?.data()?.length ||
			isLoadingChartData
		) {
			return;
		}
		// Check excluded conditions early
		if (trade.conditions?.some((condition) => excludedConditions.has(condition))) {
			return;
		}

		// Check extended hours early
		const isExtendedHours = extendedHours(trade.timestamp);
		if (
			isExtendedHours &&
			(!currentChartInstance.extendedHours || /^[dwm]/.test(currentChartInstance.timeframe || ''))
		) {
			return;
		}

		const dolvol = get(settings).dolvol;
		const mostRecentBar = chartCandleSeries.data().at(-1);
		if (!mostRecentBar) return;

		// Type guard for CandlestickData
		const isCandlestick = (data: any): data is CandlestickData<Time> =>
			data &&
			typeof data === 'object' &&
			'open' in data &&
			'high' in data &&
			'low' in data &&
			'close' in data;

		// Type guard for HistogramData
		const isHistogram = (data: any): data is HistogramData<Time> =>
			data && typeof data === 'object' && 'value' in data;

		if (!isCandlestick(mostRecentBar)) return;

		currentBarTimestamp = mostRecentBar.time as number;
		const tradeTime = UTCSecondstoESTSeconds(trade.timestamp / 1000);
		const sameBar = tradeTime < currentBarTimestamp + chartTimeframeInSeconds;

		if (sameBar) {
			// Use throttled updates
			const now = Date.now();

			// Initialize pendingBarUpdate if this is the first update in this throttle window
			if (!pendingBarUpdate) {
				pendingBarUpdate = {
					time: mostRecentBar.time,
					open: mostRecentBar.open,
					high: mostRecentBar.high,
					low: mostRecentBar.low,
					close: mostRecentBar.close
				};
			}

			// Initialize pendingVolumeUpdate
			if (!pendingVolumeUpdate) {
				const lastVolume = chartVolumeSeries.data().at(-1);
				if (lastVolume && isHistogram(lastVolume)) {
					pendingVolumeUpdate = {
						time: mostRecentBar.time,
						value: lastVolume.value,
						color: mostRecentBar.close > mostRecentBar.open ? '#089981' : '#ef5350'
					};
				}
			}

			// Update pending data with new trade
			if (
				trade.size >= 100 &&
				!trade.conditions?.some((condition) => excludedConditions.has(condition))
			) {
				pendingBarUpdate.high = Math.max(pendingBarUpdate.high, trade.price);
				pendingBarUpdate.low = Math.min(pendingBarUpdate.low, trade.price);
				pendingBarUpdate.close = trade.price;
			}
			if (pendingVolumeUpdate) {
				pendingVolumeUpdate.value += trade.size;
				pendingVolumeUpdate.color =
					pendingBarUpdate.close > pendingBarUpdate.open ? '#089981' : '#ef5350';
			}

			// Apply updates only if throttle time has passed
			if (now - lastUpdateTime >= updateThrottleMs) {
				if (pendingBarUpdate) {
					chartCandleSeries.update(pendingBarUpdate);
					pendingBarUpdate = null;
				}

				if (pendingVolumeUpdate) {
					chartVolumeSeries.update(pendingVolumeUpdate);
					pendingVolumeUpdate = null;
				}

				lastUpdateTime = now;
			}

			return;
		}

		// Create new bar - immediate update for new bars
		// Reset throttling state for new bars
		if (pendingBarUpdate) {
			chartCandleSeries.update(pendingBarUpdate);
			pendingBarUpdate = null;
		}

		if (pendingVolumeUpdate) {
			chartVolumeSeries.update(pendingVolumeUpdate);
			pendingVolumeUpdate = null;
		}

		lastUpdateTime = Date.now();

		const referenceStartTime = getReferenceStartTimeForDateMilliseconds(
			trade.timestamp,
			currentChartInstance.extendedHours
		);
		const timeDiff = (trade.timestamp - referenceStartTime) / 1000;
		const flooredDifference =
			Math.floor(timeDiff / chartTimeframeInSeconds) * chartTimeframeInSeconds;
		const newTime = UTCSecondstoESTSeconds(
			referenceStartTime / 1000 + flooredDifference
		) as UTCTimestamp;

		// Update with new bar
		chartCandleSeries.update({
			time: newTime,
			open: trade.price,
			high: trade.price,
			low: trade.price,
			close: trade.price
		});

		chartVolumeSeries.update({
			time: newTime,
			value: trade.size,
			color: '#089981' // Default to green for new bars
		});

		// Fetch and update historical data
		try {
			const timeToRequestForUpdatingAggregate =
				ESTSecondstoUTCSeconds(mostRecentBar.time as number) * 1000;
			console.log('timeToRequestForUpdatingAggregate:', timeToRequestForUpdatingAggregate);
			const [barData] = await privateRequest<BarData[]>('getChartData', {
				securityId: chartSecurityId,
				timeframe: chartTimeframe,
				timestamp: timeToRequestForUpdatingAggregate,
				direction: 'backward',
				bars: 1,
				extendedHours: chartExtendedHours,
				isreplay: $streamInfo.replayActive
			});

			if (!barData) return;

			// Find and update the matching bar
			const allCandleData = [...chartCandleSeries.data()] as Array<CandlestickData<Time>>;
			const barIndex = allCandleData.findIndex(
				(candle) => candle.time === UTCSecondstoESTSeconds(barData.time)
			);

			if (barIndex !== -1) {
				// Create safe mutable copies for data updates
				function createMutableCopy<T>(data: readonly T[]): T[] {
					return [...data];
				}

				// Update bar data with safe copies
				const updatedCandle = {
					time: UTCSecondstoESTSeconds(barData.time) as UTCTimestamp,
					open: barData.open,
					high: barData.high,
					low: barData.low,
					close: barData.close
				};

				// Create a new mutable copy of the data array before updating it
				const updatedCandleData = createMutableCopy(allCandleData);
				updatedCandleData[barIndex] = updatedCandle;
				chartCandleSeries.setData(updatedCandleData);

				// Create a new mutable copy of the volume data array before updating it
				const updatedVolumeData = createMutableCopy(chartVolumeSeries.data());
				updatedVolumeData[barIndex] = {
					time: UTCSecondstoESTSeconds(barData.time) as UTCTimestamp,
					value: barData.volume * (dolvol ? barData.close : 1),
					color: barData.close > barData.open ? '#089981' : '#ef5350'
				};
				chartVolumeSeries.setData([...updatedVolumeData] as Array<HistogramData<Time>>);
			}
		} catch (error) {
			console.error('Error fetching historical data:', error);
		}
	}

	// Add subscription to activeAlerts store to update alert lines
	$: if ($activeAlerts && chartCandleSeries) {
		// Remove existing alert lines
		alertLines.forEach((line) => {
			chartCandleSeries.removePriceLine(line.line);
		});
		alertLines = [];

		// Add new alert lines for price alerts
		$activeAlerts.forEach((alert) => {
			if (alert.alertType === 'price' && alert.alertPrice && alert.securityId === chartSecurityId) {
				const priceLine = chartCandleSeries.createPriceLine({
					price: alert.alertPrice,
					color: '#FFB74D', // Orange color for alert lines
					lineWidth: 1,
					lineStyle: 1, // Dashed line
					axisLabelVisible: true,
					title: `Alert: ${alert.alertPrice}`
					// Make lines unclickable by not adding any interactive properties
				});

				// Fix the alert ID type
				if (alert.alertId !== undefined) {
					alertLines.push({
						price: alert.alertPrice,
						line: priceLine,
						alertId: alert.alertId
					});
				}
			}
		});
	}

	function change(newReq: ChartQueryDispatch) {
		const securityId =
			typeof newReq.securityId === 'string'
				? parseInt(newReq.securityId, 10)
				: newReq.securityId || 0;

		const chartId =
			typeof newReq.chartId === 'string' ? parseInt(newReq.chartId, 10) : newReq.chartId;

		const updatedReq: ChartInstance = {
			ticker: newReq.ticker || currentChartInstance.ticker,
			timestamp: newReq.timestamp ?? currentChartInstance.timestamp,
			timeframe: newReq.timeframe || '1d',
			securityId: securityId,
			price: newReq.price ?? currentChartInstance.price,
			chartId: chartId,
			bars: newReq.bars ?? defaultBarsOnScreen,
			direction: newReq.direction,
			requestType: newReq.requestType,
			includeLastBar: newReq.includeLastBar,
			extendedHours: newReq.extendedHours
		};

		// Update currentChartInstance
		currentChartInstance = {
			...currentChartInstance,
			...updatedReq
		};

		if (
			typeof chartId === 'number' &&
			typeof updatedReq.chartId === 'number' &&
			chartId !== updatedReq.chartId
		) {
			return;
		}

		if (!updatedReq.securityId || !updatedReq.ticker || !updatedReq.timeframe) {
			return;
		}

		// Rest of the function remains the same
		chartEarliestDataReached = false;
		chartLatestDataReached = false;
		chartSecurityId = updatedReq.securityId;
		chartTimeframe = updatedReq.timeframe;
		chartTimeframeInSeconds = timeframeToSeconds(updatedReq.timeframe);
		chartExtendedHours = updatedReq.extendedHours ?? false;

		// Apply time scale options
		if (chart) {
			if (
				updatedReq.timeframe?.includes('m') ||
				updatedReq.timeframe?.includes('w') ||
				updatedReq.timeframe?.includes('d') ||
				updatedReq.timeframe?.includes('q')
			) {
				chart.applyOptions({ timeScale: { timeVisible: false } });
			} else {
				chart.applyOptions({ timeScale: { timeVisible: true } });
			}
		}

		backendLoadChartData(updatedReq);

		// Clear existing alert lines when changing tickers
		if (chartCandleSeries) {
			alertLines.forEach((line) => {
				chartCandleSeries.removePriceLine(line.line);
			});
			alertLines = [];
		}

		if (eventSeries) {
			eventSeries.setData([]);
		}
		if (arrowSeries) {
			arrowSeries.setData([]);
		}

		// Reset session highlighting when changing securities
		if (sessionHighlighting) {
			chartCandleSeries.detachPrimitive(sessionHighlighting);
			sessionHighlighting = new SessionHighlighting(createDefaultSessionHighlighter());
			chartCandleSeries.attachPrimitive(sessionHighlighting);
		}
	}

	onMount(() => {
		const chartOptions = {
			autoSize: true,
			crosshair: {
				mode: CrosshairMode.Normal
			},
			layout: {
				textColor: 'white',
				background: {
					type: ColorType.Solid,
					color: 'black'
				}
			},
			grid: {
				vertLines: {
					visible: false
				},
				horzLines: {
					visible: false
				}
			},
			timeScale: {
				timeVisible: true
			}
		};
		const chartContainer = document.getElementById(`chart_container-${chartId}`);
		if (!chartContainer) {
			return;
		}
		//init event listeners
		chartContainer.addEventListener('contextmenu', (event: MouseEvent) => {
			event.preventDefault();
			if (!chartCandleSeries) return;

			const price = chartCandleSeries.coordinateToPrice(event.clientY);
			if (typeof price !== 'number') return;

			const timestamp = ESTSecondstoUTCMillis(latestCrosshairPositionTime);
			const roundedPrice = Math.round(price * 100) / 100;

			const inst: CoreInstance = {
				ticker: currentChartInstance.ticker,
				timestamp: currentChartInstance.timestamp,
				timeframe: currentChartInstance.timeframe,
				securityId: currentChartInstance.securityId,
				price: roundedPrice
			};
			queryInstanceRightClick(event, inst, 'chart');
		});
		chartContainer.addEventListener('keyup', (event) => {
			if (event.key == 'Shift') {
				shiftDown = false;
			}
		});
		chartContainer.addEventListener('mousedown', handleMouseDown);
		chartContainer.addEventListener('mouseup', () => {
			isPanning = false;
			if (queuedLoad != null) {
				queuedLoad();
			}
		});
		chartContainer.addEventListener('keydown', (event) => {
			setActiveChart(chartId, currentChartInstance);
			if (event.key == 'r' && event.altKey) {
				// alt + r reset view
				if (currentChartInstance.timestamp && !$streamInfo.replayActive) {
					queryChart({ timestamp: 0 });
				} else {
					chart.timeScale().resetTimeScale();
				}

				// IMPORTANT: Prevent fall-through so Alt+R doesn't open the input window
				event.stopPropagation();
				event.preventDefault();
				return;
			} else if (event.key == 'h' && event.altKey) {
				const price = chartCandleSeries.coordinateToPrice(latestCrosshairPositionY);
				if (typeof price !== 'number') return;

				const roundedPrice = Math.round(price * 100) / 100;
				const securityId = currentChartInstance.securityId;
				addHorizontalLine(roundedPrice, securityId);
			} else if (event.key == 's' && event.altKey) {
				handleScreenshot(chartId.toString());
			} else if (
				event.key === 'Tab' ||
				(!event.ctrlKey &&
					!event.altKey &&
					!event.metaKey &&
					/^[a-zA-Z0-9]$/.test(event.key.toLowerCase()))
			) {
				// Prevent default and stop propagation immediately
				event.preventDefault();
				event.stopPropagation();
				
				// Add the keypress to our buffer
				if (event.key !== 'Tab') {
					keyBuffer.push(event.key);
				}
				
				// If this is the first key, start the input process
				if (!isInputActive) {
					isInputActive = true;
					
					// Create the initial instance with the buffer contents so far
					const initialInputString = keyBuffer.join('');
					const partialInstance: ChartInstance = {
						ticker: currentChartInstance.ticker,
						timestamp: currentChartInstance.timestamp,
						timeframe: currentChartInstance.timeframe,
						securityId: ensureNumericSecurityId(currentChartInstance),
						price: currentChartInstance.price,
						chartId: currentChartInstance.chartId,
						extendedHours: currentChartInstance.extendedHours,
						inputString: initialInputString // Pass the buffer as the initial string
					};
					
					// Initiate the input window with the whole buffer string
					queryInstanceInput('any', 'any', partialInstance)
						.then((value: CoreInstance) => {
							// Handle normal completion
							isInputActive = false;
							keyBuffer = []; // Clear buffer
							
							const securityId =
								typeof value.securityId === 'string'
									? parseInt(value.securityId, 10)
									: value.securityId || 0;

							const extendedV: ChartInstance = {
								ticker: value.ticker || '',
								timestamp: value.timestamp || 0,
								timeframe: value.timeframe || '',
								securityId: securityId,
								price: value.price || 0,
								chartId: currentChartInstance.chartId,
								extendedHours: value.extendedHours
							};
							currentChartInstance = extendedV;
							queryChart(extendedV, true);
							setTimeout(() => chartContainer.focus(), 0);
						})
						.catch((error) => {
							isInputActive = false;
							keyBuffer = []; // Clear buffer
							console.error('Input error:', error);
							setTimeout(() => chartContainer.focus(), 0);
						});
				}
			} else if (event.key == 'Shift') {
				shiftDown = true;
			} else if (event.key == 'Escape') {
				// Clear buffer on escape
				keyBuffer = [];
				isInputActive = false;
				
				if (get(shiftOverlay).isActive) {
					shiftOverlay.update((v: ShiftOverlay): ShiftOverlay => {
						if (v.isActive) {
							return {
								...v,
								isActive: false,
								width: 0,
								height: 0
							};
						}
						return v;
					});
				}
			}
		});
		chart = createChart(chartContainer, chartOptions);

		// Then add your candlestick / volume / etc. after or before.
		chartCandleSeries = chart.addCandlestickSeries({
			priceLineVisible: false,
			upColor: '#089981',
			downColor: '#ef5350',
			borderVisible: false,
			wickUpColor: '#089981',
			wickDownColor: '#ef5350'
		});
		chartVolumeSeries = chart.addHistogramSeries({
			lastValueVisible: true,
			priceLineVisible: false,
			priceFormat: { type: 'volume' },
			priceScaleId: ''
		});
		chartVolumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });
		chartCandleSeries.priceScale().applyOptions({ scaleMargins: { top: 0.1, bottom: 0.2 } });
		const smaOptions: DeepPartial<LineStyleOptions & SeriesOptionsCommon> = {
			lineWidth: 1,
			priceLineVisible: false,
			lastValueVisible: false
		};
		sma10Series = chart.addLineSeries({ color: 'purple', ...smaOptions });
		sma20Series = chart.addLineSeries({ color: 'blue', ...smaOptions });
		vwapSeries = chart.addLineSeries({ color: 'white', ...smaOptions });
		//rvolSeries = chart.addLineSeries({color:'green',...smaOptions})
		bidLine = chart.addLineSeries({
			color: 'white',
			lineWidth: 2,
			lastValueVisible: true, // Shows the price on the right
			priceLineVisible: false
		});
		askLine = chart.addLineSeries({
			color: 'white',
			lineWidth: 2,
			lastValueVisible: true, // Shows the price on the right
			priceLineVisible: false
		});
		arrowSeries = chart.addCustomSeries<ArrowMarker, CustomSeriesOptions>(
			new ArrowMarkersPaneView(),
			{
				title: '',
				priceScaleId: 'right'
			}
		);
		eventMarkerView = new EventMarkersPaneView();
		eventSeries = chart.addCustomSeries(eventMarkerView, {
			priceFormat: {
				type: 'custom',
				minMove: 0.00000001,
				formatter: (price: any) => {
					return '';
				}
			}
		}) as ISeriesApi<'Custom', Time, EventMarker>;

		chart.subscribeCrosshairMove((param) => {
			if (!chartCandleSeries.data().length || !param.point || !currentChartInstance.securityId) {
				return;
			}
			const volumeData = param.seriesData.get(chartVolumeSeries);
			const volume =
				volumeData && 'value' in volumeData ? (volumeData as HistogramData<Time>).value : 0;
			const allCandleData = [...chartCandleSeries.data()] as Array<CandlestickData<Time>>;
			const validCrosshairPoint = !(
				param === undefined ||
				param.time === undefined ||
				param.point.x < 0 ||
				param.point.y < 0
			);
			let bar;
			let cursorBarIndex: number | undefined;
			if (!validCrosshairPoint) {
				if (param?.logical !== undefined && param.logical < 0) {
					bar = allCandleData[0];
				}
			} else {
				bar = param.seriesData.get(chartCandleSeries);
				if (!bar) {
					return;
				}
			}

			// Type guard to check if bar is CandlestickData
			const isCandlestick = (data: any): data is CandlestickData<Time> =>
				data &&
				typeof data === 'object' &&
				'open' in data &&
				'high' in data &&
				'low' in data &&
				'close' in data;

			if (!isCandlestick(bar)) {
				return; // Skip if the bar is not CandlestickData
			}

			// Get cursor bar index if it wasn't set in the validCrosshairPoint block
			if (validCrosshairPoint && cursorBarIndex === undefined) {
				const cursorTime = bar.time as number;
				cursorBarIndex = allCandleData.findIndex((candle) => candle.time === cursorTime);
			}

			// Ensure cursorBarIndex is defined before using it
			if (cursorBarIndex === undefined) return;

			let barsForADR;
			if (cursorBarIndex >= 20) {
				barsForADR = allCandleData.slice(cursorBarIndex - 19, cursorBarIndex + 1);
			} else {
				barsForADR = allCandleData.slice(0, cursorBarIndex + 1);
			}
			let chg = 0;
			let chgprct = 0;
			if (cursorBarIndex > 0) {
				const prevBar = allCandleData[cursorBarIndex - 1];

				if (isCandlestick(prevBar)) {
					chg = bar.close - prevBar.close;
					chgprct = (bar.close / prevBar.close - 1) * 100;
				}
			}

			hoveredCandleData.set({
				open: bar.open,
				high: bar.high,
				low: bar.low,
				close: bar.close,
				volume: volume,
				adr: calculateSingleADR(
					barsForADR.filter(
						(candle) =>
							candle &&
							typeof candle === 'object' &&
							'open' in candle &&
							'high' in candle &&
							'low' in candle &&
							'close' in candle
					) as CandlestickData<Time>[]
				),
				chg: chg,
				chgprct: chgprct,
				rvol: 0
			});
			if (currentChartInstance.timeframe && /^\d+$/.test(currentChartInstance.timeframe)) {
				let barsForRVOL;
				if (cursorBarIndex !== undefined && cursorBarIndex >= 1000) {
					barsForADR = allCandleData.slice(cursorBarIndex - 1000, cursorBarIndex + 1);
				} else if (cursorBarIndex !== undefined) {
					// Transform the histogram data to the format expected by calculateRVOL
					const volumeData = chartVolumeSeries.data().slice(0, cursorBarIndex + 1);
					barsForRVOL = volumeData
						.filter((bar) => bar && typeof bar === 'object' && 'value' in bar) // Filter to ensure only HistogramData is included
						.map((bar) => ({
							time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp,
							value: (bar as HistogramData<Time>).value || 0
						}));
				}
				// Only call calculateRVOL if barsForRVOL is defined
				if (barsForRVOL && barsForRVOL.length > 0) {
					calculateRVOL(barsForRVOL, currentChartInstance.securityId).then((r: any) => {
						hoveredCandleData.update((v) => {
							v.rvol = r;
							return v;
						});
					});
				}
			}
			latestCrosshairPositionTime = bar.time as number;
			latestCrosshairPositionY = param.point.y as number; //inccorect
		});
		chart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
			if (!logicalRange || Date.now() - lastChartQueryDispatchTime < chartRequestThrottleDuration) {
				return;
			}
			const barsOnScreen = Math.floor(logicalRange.to) - Math.ceil(logicalRange.from);
			const bufferInScreenSizes = 0.7;
			if (logicalRange.from / barsOnScreen < bufferInScreenSizes) {
				if (chartEarliestDataReached) {
					return;
				}
				('2');
				
				// Get the earliest timestamp from current data
				const earliestBar = chartCandleSeries.data()[0];
				if (!earliestBar) return;
				
				// Convert the earliest time from EST seconds to UTC milliseconds for the API request
				const earliestTimestamp = ESTSecondstoUTCMillis(earliestBar.time as UTCTimestamp);
				
				// Make sure to include extendedHours in the request
				const inst: CoreInstance & { extendedHours?: boolean } = {
					ticker: currentChartInstance.ticker,
					timestamp: earliestTimestamp,
					timeframe: currentChartInstance.timeframe,
					securityId: currentChartInstance.securityId,
					price: currentChartInstance.price,
					extendedHours: currentChartInstance.extendedHours
				};
				
				backendLoadChartData({
					...inst,
					bars: Math.floor(bufferInScreenSizes * barsOnScreen) + 100,
					direction: 'backward',
					requestType: 'loadAdditionalData',
					includeLastBar: true
				});
			} else if (
				(chartCandleSeries.data().length - logicalRange.to) / barsOnScreen <
				bufferInScreenSizes
			) {
				// forward load
				if (chartLatestDataReached) {
					return;
				}
				if ($streamInfo.replayActive) {
					return;
				}
				('3');
				
				// Also fix the forward load to include extendedHours
				const inst: CoreInstance & { extendedHours?: boolean } = {
					ticker: currentChartInstance.ticker,
					timestamp: currentChartInstance.timestamp,
					timeframe: currentChartInstance.timeframe,
					securityId: currentChartInstance.securityId,
					price: currentChartInstance.price,
					extendedHours: currentChartInstance.extendedHours
				};
				
				backendLoadChartData({
					...inst,
					bars: Math.floor(bufferInScreenSizes * barsOnScreen) + 100,
					direction: 'forward',
					requestType: 'loadAdditionalData',
					includeLastBar: true
				});
			}
		});

		// Add mousemove handler for the chart container
		const container = document.getElementById(`chart_container-${chartId}`);
		container?.addEventListener('mousemove', (e) => {
			const rect = container.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;

			// Pass mouse move to event marker view
			if (eventMarkerView && eventMarkerView.handleMouseMove(x, y)) {
				// If the state changed and we need a redraw, request one
				chart.applyOptions({});
			}
		});

		container?.addEventListener('mouseleave', () => {
			if (eventMarkerView && eventMarkerView.clearHover()) {
				// If we cleared the hover state, request a redraw
				hoveredEvent = null;
				chart.applyOptions({});
			}
		});

		container?.addEventListener('click', (e) => {
			const rect = container.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;

			if (eventMarkerView.handleClick(x, y)) {
				e.preventDefault();
				e.stopPropagation();
			} else {
				// Click outside filing - close the popup
				selectedEvent = null;
			}
		});

		eventMarkerView.setClickCallback(handleEventClick);
		eventMarkerView.setHoverCallback(handleEventHover);

		// Add subscriptions after chart initialization
		chartQueryDispatcher.subscribe((req: ChartQueryDispatch) => {
			change(req);
		});

		chartEventDispatcher.subscribe((e: ChartEventDispatch) => {
			if (!currentChartInstance || !currentChartInstance.securityId) return;
			if (e.event == 'replay') {
				currentChartInstance.timestamp = 0;
				const req: ChartQueryDispatch = {
					...currentChartInstance,
					bars: 300,
					direction: 'backward',
					requestType: 'loadNewTicker',
					includeLastBar: false,
					chartId: chartId
				};
				change(req);
			} else if (e.event == 'addHorizontalLine') {
				addHorizontalLine(e.data.price, e.data.securityId);
			}
		});

		chartContainer.setAttribute('tabindex', '0'); // Make container focusable
		chartContainer.focus(); // Focus the container

		// Create session highlighting
		if (chart) {
			sessionHighlighting = new SessionHighlighting(createDefaultSessionHighlighter());
			chartCandleSeries.attachPrimitive(sessionHighlighting);
		}

		return () => {
			// Apply any pending updates before unmounting
			if (pendingBarUpdate) {
				chartCandleSeries.update(pendingBarUpdate);
			}

			if (pendingVolumeUpdate) {
				chartVolumeSeries.update(pendingVolumeUpdate);
			}

			// ... any other cleanup code ...
		};
	});

	// Handle event marker clicks
	function handleEventClick(events: EventMarker['events'], x: number, y: number) {
		// Check if clicking on the same event that's already selected
		if (
			selectedEvent &&
			Math.abs(selectedEvent.x - x) < 10 &&
			Math.abs(selectedEvent.y - y) < 10 &&
			selectedEvent.events.length === events.length
		) {
			// If clicking on the same event, close the popup
			selectedEvent = null;
		} else {
			// Otherwise, select the new event
			selectedEvent = { events, x, y };
			hoveredEvent = null; // Clear hover when clicked
		}
	}

	// Handle event marker hover
	function handleEventHover(events: EventMarker['events'] | null, x: number, y: number) {
		if (events) {
			hoveredEvent = { events, x, y };
		} else {
			hoveredEvent = null;
		}
	}

	// Handle closing the event popup
	function closeEventPopup() {
		selectedEvent = null;
	}

	function handleShiftOverlayEnd(event: MouseEvent) {
		shiftOverlay.update((v: ShiftOverlay): ShiftOverlay => {
			if (v.isActive) {
				return {
					...v,
					isActive: false,
					width: 0,
					height: 0
				};
			}
			return v;
		});
		document.removeEventListener('mousemove', shiftOverlayTrack);
		document.removeEventListener('mouseup', handleShiftOverlayEnd);
	}

	// New interface for the data object
	interface ChartData {
		type?: string;
		url?: string;
		ratio?: number;
		amount?: number;
	}

	// Type guard for the data object
	function isChartData(data: unknown): data is ChartData {
		return typeof data === 'object' && data !== null;
	}

	// Use in the code
	const data: ChartData = {};
	if (isChartData(data)) {
		if (data.type && data.url) {
			// Handle type and url
		}
		if (typeof data.ratio === 'number') {
			// Handle ratio
		}
		if (typeof data.amount === 'number') {
			// Handle amount
		}
	}

	// Handle Instance type
	const createInstance = (chartInstance: Partial<CoreInstance>): CoreInstance => ({
		ticker: chartInstance.ticker || '',
		timestamp: chartInstance.timestamp || 0,
		timeframe: chartInstance.timeframe || '',
		securityId:
			typeof chartInstance.securityId === 'string'
				? parseInt(chartInstance.securityId, 10)
				: chartInstance.securityId || 0,
		price: chartInstance.price || 0
	});


	// Handle bars calculation safely
	const calculateBars = (instance: Partial<ChartInstance>): number => {
		return instance.bars || Math.floor(bufferInScreenSizes * defaultBarsOnScreen) + 100;
	};

	function ensureNumericSecurityId(instance: ExtendedInstance | CoreInstance): number {
		const securityId = instance.securityId;
		if (typeof securityId === 'string') {
			return parseInt(securityId, 10);
		}
		if (typeof securityId === 'number') {
			return securityId;
		}
		return 0; // Default value if undefined
	}



</script>

<div class="chart" id="chart_container-{chartId}" style="width: {width}px" tabindex="-1">
	<Legend instance={currentChartInstance} {hoveredCandleData} {width} />
	<Shift {shiftOverlay} />
	<DrawingMenu {drawingMenuProps} />
</div>

<!-- Replace the filing info overlay with a more generic event info overlay -->
{#if selectedEvent}
	<div
		class="event-info"
		style="
            left: {selectedEvent.x - 100}px; 
            top: {selectedEvent.y - (80 + selectedEvent.events.length * 40)}px"
	>
		<div class="event-header">
			{#if selectedEvent.events[0]?.type === 'sec_filing'}
				<div class="event-icon" style="color: #9C27B0;">ðŸ“„</div>
				<div class="event-title">SEC Filings</div>
			{:else if selectedEvent.events[0]?.type === 'split'}
				<div class="event-icon" style="color: #FFD700;">ðŸ“Š</div>
				<div class="event-title">Stock Splits</div>
			{:else if selectedEvent.events[0]?.type === 'dividend'}
				<div class="event-icon" style="color: #2196F3;">ðŸ’°</div>
				<div class="event-title">Dividends</div>
			{:else}
				<div class="event-icon">ðŸ“…</div>
				<div class="event-title">Events</div>
			{/if}
			<button class="close-button" on:click={closeEventPopup}>Ã—</button>
		</div>
		<div class="event-content">
			{#each selectedEvent.events as event}
				{#if event.type === 'sec_filing'}
					<a
						href={event.url}
						target="_blank"
						rel="noopener noreferrer"
						class="event-row filing-link"
					>
						<span class="event-type">{event.title}</span>
						<span class="event-link">View â†’</span>
					</a>
				{:else if event.type === 'split'}
					<div class="event-row">
						<span class="event-type">{event.title}</span>
					</div>
				{:else if event.type === 'dividend'}
					<div class="event-row dividend-row">
						<div class="dividend-details">
							<span class="event-type">{event.title}</span>
							{#if event.exDate}
								<span class="dividend-date">Ex-Date: {event.exDate}</span>
							{/if}
							{#if event.payoutDate}
								<span class="dividend-date">Payout: {event.payoutDate}</span>
							{/if}
						</div>
					</div>
				{:else}
					<div class="event-row">
						<span class="event-type">{event.title}</span>
					</div>
				{/if}
			{/each}
		</div>
	</div>
{/if}

<style>
	.event-info {
		position: absolute;
		background: #1e1e1e;
		border: 1px solid #333;
		border-radius: 4px;
		padding: 8px;
		z-index: 1000;
		width: 220px; /* Increased width to accommodate more content */
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
		transform: translateX(0); /* Center popup above marker */
	}

	.event-header {
		display: flex;
		align-items: center;
		gap: 8px;
		padding-bottom: 8px;
		border-bottom: 1px solid #333;
		margin-bottom: 8px;
		position: relative;
	}

	.close-button {
		position: absolute;
		right: 0;
		top: 0;
		background: none;
		border: none;
		color: #888;
		font-size: 18px;
		cursor: pointer;
		padding: 0 4px;
	}

	.close-button:hover {
		color: #fff;
	}

	.event-icon {
		font-size: 1.2rem;
	}

	.event-title {
		font-weight: bold;
	}

	.event-content {
		max-height: 150px;
		overflow-y: auto;
	}

	.event-row {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 4px 0;
		border-bottom: 1px solid #333;
		color: #fff;
		text-decoration: none;
	}

	.event-row:last-child {
		border-bottom: none;
	}

	.event-type {
		font-size: 0.9rem;
	}

	.event-link {
		color: #4caf50;
		font-size: 0.8rem;
	}

	.filing-link {
		cursor: pointer;
		transition: background-color 0.2s;
	}

	.filing-link:hover {
		background-color: #333;
	}

	.dividend-row {
		flex-direction: column;
		align-items: flex-start;
	}

	.dividend-details {
		display: flex;
		flex-direction: column;
		width: 100%;
	}

	.dividend-date {
		font-size: 0.8rem;
		color: #bbb;
		margin-top: 2px;
	}
</style>

```

```chart/chartContainer.svelte
<file>/home/aj/dev/study/services/frontend/src/lib/features/chart/chartContainer.svelte</file>
<script lang="ts">
	import Chart from './chart.svelte';
	import { settings } from '$lib/core/stores';
	import { onMount, tick } from 'svelte';
	import { get } from 'svelte/store';
	import { queryInstanceInput } from '$lib/utils/popups/input.svelte';
	import { queryChart } from './interface';
	export let width: number;

	// Add focus management
	let containerRef: HTMLDivElement;

	onMount(() => {
		// Wait for DOM to be ready
		tick().then(() => {
			if (containerRef) {
				containerRef.focus();
			}
		});

		// Add global keyboard event listener for chart container
		const handleGlobalKeydown = (event: KeyboardEvent) => {
			// Check if input popup is active by looking for the hidden input
			const hiddenInput = document.getElementById('hidden-input');
			if (hiddenInput && document.activeElement === hiddenInput) {
				// Input popup is active, don't trigger new input
				return;
			}

			// Check if the user is currently in any standard input field
			const activeElement = document.activeElement;
			const isInputField =
				activeElement?.tagName === 'INPUT' ||
				activeElement?.tagName === 'TEXTAREA' ||
				activeElement?.getAttribute('contenteditable') === 'true';

			// If user is typing in any input field, don't intercept keystrokes
			if (isInputField) {
				return;
			}

			if (/^[a-zA-Z0-9]$/.test(event.key) && !event.ctrlKey && !event.metaKey) {
				// Create an initial instance with the first key as the inputString
				const initialKey = event.key.toUpperCase();

				// Use type assertion to allow the inputString property
				const instanceWithInput = {
					inputString: initialKey
				} as any;

				queryInstanceInput(
					'any',
					['ticker', 'timeframe', 'timestamp', 'extendedHours'],
					instanceWithInput
				).then((updatedInstance) => {
					queryChart(updatedInstance, true);
					console.log('Updated instance:', updatedInstance);
				});
				console.log('Global keydown event:', {
					key: event.key,
					ctrlKey: event.ctrlKey,
					metaKey: event.metaKey
				});

				// Only focus if we're not in an input field or similar
				if (containerRef) {
					containerRef.focus();
				}
			}
		};

		document.addEventListener('keydown', handleGlobalKeydown);
		return () => {
			document.removeEventListener('keydown', handleGlobalKeydown);
		};
	});

	// Handle focus management
	function handleKeyDown(event: KeyboardEvent) {
		if (event.key === 'Tab') {
			event.preventDefault(); // Prevent default tab behavior
		}
	}
</script>

<div
	class="chart-container"
	bind:this={containerRef}
	tabindex="0"
	role="application"
	aria-label="Chart Container"
	on:keydown={handleKeyDown}
>
	{#each Array.from({ length: $settings.chartRows }) as _, j}
		<div class="row" style="height: calc(100% / {$settings.chartRows})">
			{#each Array.from({ length: $settings.chartColumns }) as _, i}
				<Chart width={width / $settings.chartColumns} chartId={i + j * $settings.chartColumns} />
			{/each}
		</div>
	{/each}
</div>

<style>
	.chart-container {
		display: flex;
		flex-direction: column;
		width: 100%;
		height: 100%;
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		outline: none; /* Remove focus outline but maintain accessibility */
	}

	.row {
		display: flex;
		width: 100%;
		justify-content: space-between;
		flex: 1;
		min-height: 0;
	}
</style>

```

</potential_codebase_context>
