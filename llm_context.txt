# Inputs

## Current File
Here is the file I'm looking at. It might be truncated from above and below and, if so, is centered around my cursor.
```input.svelte


```app/page.svelte


```chart.svelte


```chartContainer.svelte


```watchlist.svelte



<potential_codebase_context>
## Potentially Relevant Code Snippets from the current Codebase

<file>/home/aj/dev/study/frontend/src/lib/utils/popups/input.svelte</file>
<!-- instance.svelte -->
<script lang="ts" context="module">
	import '$lib/core/global.css';
	import { privateRequest } from '$lib/core/backend';
	import { get, writable } from 'svelte/store';
	import { parse } from 'date-fns';
	import { tick } from 'svelte';
	import type { Writable } from 'svelte/store';
	import type { Instance } from '$lib/core/types';

	/**
	 * Simplified Focus Management Strategy:
	 * 1. When input component is activated, we store the previously focused element
	 * 2. We focus the input window itself and handle keyboard events directly
	 * 3. When input is completed or cancelled, we restore focus to the previously focused element
	 * 4. We clean up all event listeners when the component is destroyed or deactivated
	 */

	const allKeys = ['ticker', 'timestamp', 'timeframe', 'extendedHours', 'price'] as const;
	let currentSecurityResultRequest = 0;

	type InstanceAttributes = (typeof allKeys)[number];
	let filterOptions = [];
	let loadedSecurityResultRequest = -1;
	privateRequest<[]>('getSecurityClassifications', {}).then((v: []) => {
		filterOptions = v;
	});
	interface InputQuery {
		// 'inactive': no UI shown
		// 'initializing' setting up event handlers
		// 'active': window is open waiting for input
		// 'complete': one field completed (may still be active if more required)
		// 'cancelled': user cancelled via Escape
		// 'shutdown': about to close and reset to inactive
		status: 'inactive' | 'initializing' | 'active' | 'complete' | 'cancelled' | 'shutdown';
		inputString: string;
		inputType: string;
		inputValid: boolean;
		instance: Instance;
		requiredKeys: InstanceAttributes[] | 'any';
		possibleKeys: InstanceAttributes[];
		securities?: Instance[];
	}

	const inactiveInputQuery: InputQuery = {
		status: 'inactive',
		inputString: '',
		inputValid: true,
		inputType: '',
		requiredKeys: 'any',
		possibleKeys: [],
		instance: {}
	};
	export const inputQuery: Writable<InputQuery> = writable({ ...inactiveInputQuery });

	// Hold the reject function of the currently active promise (if any)
	let activePromiseReject: ((reason?: any) => void) | null = null;

	// Modified queryInstanceInput: if called while another query is active,
	// cancel the previous query (rejecting its promise) and reset the state.
	export async function queryInstanceInput(
		requiredKeys: InstanceAttributes[] | 'any',
		optionalKeys: InstanceAttributes[] | 'any',
		instance: Instance = {}
	): Promise<Instance> {
		// If an input query is already active, force its cancellation.
		if (get(inputQuery).status !== 'inactive') {
			if (activePromiseReject) {
				activePromiseReject(new Error('User cancelled input'));
				activePromiseReject = null;
			}
			inputQuery.update((q) => ({ ...inactiveInputQuery }));
			// Optionally wait a tick for the UI to update.
			await tick();
		}

		// Determine possible keys.
		let possibleKeys: InstanceAttributes[];
		if (optionalKeys === 'any') {
			possibleKeys = [...allKeys];
		} else {
			possibleKeys = Array.from(
				new Set([...requiredKeys, ...optionalKeys])
			) as InstanceAttributes[];
		}
		await tick();

		// Check if there's an initial inputString in the instance
		const initialInputString =
			'inputString' in instance && instance['inputString'] != null
				? String(instance['inputString'])
				: '';
		// Remove inputString property (not part of the Instance interface)
		if ('inputString' in instance) {
			const instanceAny = instance as any;
			delete instanceAny.inputString;
		}

		// Initialize the query with passed instance info.
		inputQuery.update((v: InputQuery) => ({
			...v,
			requiredKeys,
			possibleKeys,
			instance,
			inputString: initialInputString, // Use the initial input string if provided
			status: 'initializing'
		}));

		// Return a new promise that resolves when input is complete or rejects on cancellation.
		return new Promise<Instance>((resolve, reject) => {
			// Save the reject function so a subsequent call can cancel this query.
			activePromiseReject = reject;

			const unsubscribe = inputQuery.subscribe((iQ: InputQuery) => {
				if (iQ.status === 'cancelled') {
					cleanup();
					reject(new Error('User cancelled input'));
				} else if (iQ.status === 'complete') {
					const result = iQ.instance;
					cleanup();
					resolve(result);
				}
			});

			function cleanup() {
				unsubscribe();
				activePromiseReject = null;
				// Trigger a shutdown to reset state.
				inputQuery.update((v: InputQuery) => ({ ...v, status: 'shutdown' }));
			}
		});
	}
</script>

<script lang="ts">
	import { browser } from '$app/environment';
	import { onDestroy, onMount } from 'svelte';
	import { ESTStringToUTCTimestamp, UTCTimestampToESTString } from '$lib/core/timestamp';
	
	// Track the previously focused element
	let prevFocusedElement: HTMLElement | null = null;
	let inputWindowElement: HTMLDivElement;
	let isLoadingSecurities = false;
	let manualInputType: string = 'auto';

	// Add this reactive statement
	$: if (manualInputType !== 'auto' && $inputQuery.status === 'active') {
		inputQuery.update((v) => ({
			...v,
			inputType: manualInputType
		}));
	}

	interface ValidateResponse {
		inputValid: boolean;
		securities: Instance[];
	}

	async function validateInput(inputString: string, inputType: string): Promise<ValidateResponse> {
		if (inputType === 'ticker') {
			isLoadingSecurities = true;
			try {
				const securities = await privateRequest<Instance[]>('getSecuritiesFromTicker', {
					ticker: inputString
				});
				if (Array.isArray(securities) && securities.length > 0) {
					return {
						inputValid: true,
						securities: securities
					};
				}
				return { inputValid: false, securities: [] };
			} finally {
				isLoadingSecurities = false;
			}
		} else if (inputType === 'timeframe') {
			const regex = /^\d{1,3}[yqmwhds]?$/i;
			return { inputValid: regex.test(inputString), securities: [] };
		} else if (inputType === 'timestamp') {
			const formats = ['yyyy-MM-dd H:m:ss', 'yyyy-MM-dd H:m', 'yyyy-MM-dd H', 'yyyy-MM-dd'];
			for (const format of formats) {
				try {
					const parsedDate = parse(inputString, format, new Date());
					if (!isNaN(parsedDate.getTime())) {
						return { inputValid: true, securities: [] };
					}
				} catch {
					/* try next format */
				}
			}
			return { inputValid: false, securities: [] };
		} else if (inputType === 'price') {
			const price = parseFloat(inputString);
			return { inputValid: !isNaN(price) && price > 0, securities: [] };
		}
		return { inputValid: false, securities: [] };
	}

	async function waitForSecurityResult(): Promise<void> {
		return new Promise((resolve) => {
			const check = () => {
				if (loadedSecurityResultRequest === currentSecurityResultRequest) {
					resolve();
				} else {
					// Check again after 50ms (or adjust as needed)
					setTimeout(check, 50);
				}
			};
			check();
		});
	}

	async function enterInput(iQ: InputQuery, tickerIndex: number = 0): Promise<InputQuery> {
		if (iQ.inputType === 'ticker') {
			const ts = iQ.instance.timestamp;
			await waitForSecurityResult();
			iQ = $inputQuery;
			if (Array.isArray(iQ.securities) && iQ.securities.length > 0) {
				iQ.instance = { ...iQ.instance, ...iQ.securities[tickerIndex] };
				iQ.instance.timestamp = ts;
			}
		} else if (iQ.inputType === 'timeframe') {
			iQ.instance.timeframe = iQ.inputString;
		} else if (iQ.inputType === 'timestamp') {
			iQ.instance.timestamp = ESTStringToUTCTimestamp(iQ.inputString);
		} else if (iQ.inputType === 'price') {
			iQ.instance.price = parseFloat(iQ.inputString);
		}
		// Mark as complete but then check if further input is needed.
		iQ.status = 'complete';
		if (iQ.requiredKeys === 'any') {
			if (Object.keys(iQ.instance).length === 0) {
				iQ.status = 'active';
			}
		} else {
			for (const attribute of iQ.requiredKeys) {
				if (!iQ.instance[attribute]) {
					iQ.status = 'active';
					break;
				}
			}
		}
		iQ.inputString = '';
		iQ.inputType = '';
		iQ.inputValid = true;
		// Reset manualInputType to auto after input is entered
		manualInputType = 'auto';
		return iQ;
	}

	// Handle keyboard input directly on the input window
	async function handleKeyDown(event: KeyboardEvent): Promise<void> {
		// Get current state directly from the store to ensure we have latest state
		const currentState = get(inputQuery);

		// Make sure we're in active state
		if (currentState.status !== 'active') {
			return;
		}

		// Always prevent default behavior for our captured keys to avoid browser handling
		if (
			event.key === 'Enter' ||
			event.key === 'Tab' ||
			event.key === 'Escape' ||
			/^[a-zA-Z0-9]$/.test(event.key) ||
			/[-:.]/.test(event.key) ||
			(event.key === ' ' && currentState.inputType === 'timestamp') ||
			event.key === 'Backspace'
		) {
			event.preventDefault();
		}

		// Stop propagation to prevent double-handling
		event.stopPropagation();

		let iQ = { ...currentState };
		if (event.key === 'Escape') {
			inputQuery.update((q) => ({ ...q, status: 'cancelled' }));
			return;
		} else if (event.key === 'Enter') {
			if (iQ.inputValid) {
				const updatedQuery = await enterInput(iQ, 0);
				inputQuery.set(updatedQuery);
			}
			return;
		} else if (event.key === 'Tab') {
			inputQuery.update((q) => ({
				...q,
				instance: { ...q.instance, extendedHours: !q.instance.extendedHours }
			}));
			return;
		}

		// Process input keys
		if (
			/^[a-zA-Z0-9]$/.test(event.key) ||
			/[-:.]/.test(event.key) ||
			(event.key === ' ' && iQ.inputType === 'timestamp')
		) {
			// Transform the key based on input type
			const key = iQ.inputType === 'timeframe' ? event.key : event.key.toUpperCase();
			const newInputString = iQ.inputString + key;

			// Update inputString immediately
			inputQuery.update((v) => ({
				...v,
				inputString: newInputString
			}));

			// Then determine input type
			determineInputType(newInputString);
		} else if (event.key === 'Backspace') {
			const newInputString = iQ.inputString.slice(0, -1);

			// Update inputString immediately
			inputQuery.update((v) => ({
				...v,
				inputString: newInputString
			}));

			// Then determine input type
			determineInputType(newInputString);
		}
	}

	function determineInputType(inputString: string): void {
		const iQ = get(inputQuery);
		let inputType = iQ.inputType;

		// Only auto-classify if manualInputType is set to 'auto'
		if (manualInputType === 'auto') {
			if (inputString !== '') {
				if (iQ.possibleKeys.includes('ticker') && /^[A-Z]$/.test(inputString)) {
					inputType = 'ticker';
				} else if (iQ.possibleKeys.includes('price') && /^(?:\d*\.\d+|\d{3,})$/.test(inputString)) {
					inputType = 'price';
				} else if (
					iQ.possibleKeys.includes('timeframe') &&
					/^\d{1,2}[hdwmqs]?$/i.test(inputString)
				) {
					inputType = 'timeframe';
				} else if (iQ.possibleKeys.includes('timestamp') && /^[\d-]+$/.test(inputString)) {
					inputType = 'timestamp';
				} else if (iQ.possibleKeys.includes('ticker')) {
					inputType = 'ticker';
				} else {
					inputType = '';
				}
			} else {
				inputType = '';
			}
		} else {
			// Use the manually selected input type
			inputType = manualInputType;
		}

		// Update the input type
		inputQuery.update((v) => ({
			...v,
			inputType
		}));

		// Trigger validation
		currentSecurityResultRequest++;
		const thisSecurityResultRequest = currentSecurityResultRequest;
		validateInput(inputString, inputType).then((validationResp: ValidateResponse) => {
			if (thisSecurityResultRequest === currentSecurityResultRequest) {
				inputQuery.update((v: InputQuery) => ({
					...v,
					...validationResp
				}));
				loadedSecurityResultRequest = thisSecurityResultRequest;
			}
		});
	}

	// Handle clicks outside the popup to close it
	function handleOutsideClick(event: MouseEvent) {
		const inputWindow = document.getElementById('input-window');
		if (!inputWindow || !inputWindow.contains(event.target as Node)) {
			inputQuery.update((v) => ({ ...v, status: 'cancelled' }));
		}
	}

	function closeWindow() {
		inputQuery.update((v) => ({ ...v, status: 'cancelled' }));
	}

	let sectors: string[] = [];
	let industries: string[] = [];
	function capitalize(str: string, lower = false): string {
		return (lower ? str.toLowerCase() : str).replace(/(?:^|\s|["'([{])+\S/g, (match: string) =>
			match.toUpperCase()
		);
	}

	function formatTimeframe(timeframe: string): string {
		const match = timeframe.match(/^(\d+)([dwmsh]?)$/i) ?? null;
		let result = timeframe;
		if (match) {
			switch (match[2]) {
				case 'd':
					result = `${match[1]} days`;
					break;
				case 'w':
					result = `${match[1]} weeks`;
					break;
				case 'm':
					result = `${match[1]} months`;
					break;
				case 'h':
					result = `${match[1]} hours`;
					break;
				case 's':
					result = `${match[1]} seconds`;
					break;
				default:
					result = `${match[1]} minutes`;
					break;
			}
			if (match[1] === '1') {
				result = result.slice(0, -1);
			}
		}
		return result;
	}

	onMount(() => {
		// Store the currently focused element
		prevFocusedElement = document.activeElement as HTMLElement;

		const unsubscribe = inputQuery.subscribe((v: InputQuery) => {
			if (browser) {
				if (v.status === 'initializing') {
					// Store focused element before showing the popup
					prevFocusedElement = document.activeElement as HTMLElement;
                    
                    // Mark the UI as active now
                    inputQuery.update((state) => ({ ...state, status: 'active' }));
                    
                    // Focus the input window after it renders
                    tick().then(() => {
                        // Focus the input window itself (will receive keyboard events)
                        if (inputWindowElement) {
                            inputWindowElement.focus();
                        }
                        
                        // Add a click handler to the document to detect clicks outside the popup
                        document.addEventListener('mousedown', handleOutsideClick);
                    });
				} else if (v.status === 'shutdown' || v.status === 'cancelled') {
					// Remove document click handler
					document.removeEventListener('mousedown', handleOutsideClick);
					
					// Restore focus to the previously focused element
					if (prevFocusedElement) {
                        tick().then(() => {
                            prevFocusedElement?.focus();
                            
                            if (v.status === 'shutdown') {
                                // Reset to inactive only after focus is restored
                                inputQuery.update((state) => ({ ...state, status: 'inactive', inputString: '' }));
                            }
                        });
					} else if (v.status === 'shutdown') {
                        // Reset to inactive if there was no previous element
                        inputQuery.update((state) => ({ ...state, status: 'inactive', inputString: '' }));
                    }
				}
			}
		});

		type SecurityClassifications = {
			sectors: string[];
			industries: string[];
		};
		privateRequest<SecurityClassifications>('getSecurityClassifications', {}, false).then(
			(classifications: SecurityClassifications) => {
				sectors = classifications.sectors;
				industries = classifications.industries;
			}
		);
		
		return () => {
			unsubscribe();
		};
	});

	onDestroy(() => {
		// Clean up any remaining event listeners
		document.removeEventListener('mousedown', handleOutsideClick);
	});
	
	function displayValue(q: InputQuery, key: string): string {
		if (key === q.inputType) {
			return q.inputString;
		} else if (key in q.instance) {
			if (key === 'timestamp') {
				return UTCTimestampToESTString(q.instance.timestamp ?? 0);
			} else if (key === 'extendedHours') {
				return q.instance.extendedHours ? 'True' : 'False';
			} else if (key === 'price') {
				return '$' + String(q.instance.price);
			} else {
				return String(q.instance[key as keyof Instance]);
			}
		}
		return '';
	}
</script>

{#if $inputQuery.status === 'active' || $inputQuery.status === 'initializing'}
	<div
		class="popup-container"
		id="input-window"
		bind:this={inputWindowElement}
		tabindex="0"
		on:keydown={handleKeyDown}
	>
		<div class="header">
			<div class="title">{capitalize($inputQuery.inputType)} Input</div>
			<div class="field-select">
				<span class="label">Field:</span>
				<select
					class="default-select"
					bind:value={manualInputType}
					on:click|stopPropagation
					on:change|stopPropagation
				>
					<option value="auto">Auto</option>
					{#each $inputQuery.possibleKeys as key}
						<option value={key}>{capitalize(key)}</option>
					{/each}
				</select>
			</div>
			<button class="utility-button" on:click|stopPropagation={closeWindow}>×</button>
		</div>

		<div class="search-bar">
			<input type="text" placeholder="Enter Value" value={$inputQuery.inputString} readonly />
		</div>
		<div class="content-container">
			{#if $inputQuery.instance && Object.keys($inputQuery.instance).length > 0}
				{#if $inputQuery.inputType === ''}
					<div class="span-container">
						{#each $inputQuery.possibleKeys as key}
							<div class="span-row">
								<span
									class={$inputQuery.requiredKeys !== 'any' &&
									$inputQuery.requiredKeys.includes(key) &&
									!$inputQuery.instance[key]
										? 'red'
										: ''}
								>
									{capitalize(key)}
								</span>
								<span class="value">
									{displayValue($inputQuery, key)}
								</span>
							</div>
						{/each}
					</div>
				{:else if $inputQuery.inputType === 'ticker'}
					<div class="table-container">
						{#if isLoadingSecurities}
							<div class="loading-container">
								<div class="loading-spinner"></div>
								<span class="label">Loading securities...</span>
							</div>
						{:else if Array.isArray($inputQuery.securities) && $inputQuery.securities.length > 0}
							<table>
								<tbody>
									{#each $inputQuery.securities as sec, i}
										<tr
											on:click={async () => {
												const updatedQuery = await enterInput($inputQuery, i);
												inputQuery.set(updatedQuery);
											}}
										>
											<td class="defalt-td">
												<div
													style="background-color: transparent; width: 100px; height: 30px; display: flex; align-items: center; justify-content: center;"
												>
													{#if sec.icon}
														<img
															src={`data:image/jpeg;base64,${sec.icon}`}
															alt="Security Image"
															style="max-width: 100%; max-height: 100%; object-fit: contain;"
														/>
													{/if}
												</div>
											</td>
											<td class="defalt-td">{sec.ticker}</td>
											<td class="defalt-td">{sec.name}</td>
											<td class="defalt-td"
												>{sec.timestamp !== undefined
													? UTCTimestampToESTString(sec.timestamp)
													: ''}</td
											>
										</tr>
									{/each}
								</tbody>
							</table>
						{/if}
					</div>
				{:else if $inputQuery.inputType === 'timestamp'}
					<div class="span-container">
						<div class="span-row">
							<span class="label">Timestamp</span>
							<input
								type="datetime-local"
								on:change={(e) => {
									// Use type casting in a different way that works better with Svelte compiler
									const target = e.target;
									const inputValue = target && 'value' in target ? String(target.value) : '';
									const date = new Date(inputValue);
									inputQuery.update((q) => ({
										...q,
										instance: {
											...q.instance,
											timestamp: !isNaN(date.getTime()) ? date.getTime() : q.instance.timestamp
										},
										inputValid: !isNaN(date.getTime())
									}));
								}}
							/>
						</div>
					</div>
				{:else if $inputQuery.inputType === 'timeframe'}
					<div class="span-container">
						<div class="span-row">
							<span class="label">Timeframe</span>
							<span class="value">{formatTimeframe($inputQuery.inputString)}</span>
						</div>
					</div>
				{:else if $inputQuery.inputType === 'extendedHours'}
					<div class="span-container">
						<div class="span-row">
							<span class="label">Extended Hours</span>
							<span class="value">{$inputQuery.instance.extendedHours ? 'True' : 'False'}</span>
						</div>
					</div>
					0
				{/if}
			{/if}
		</div>
	</div>
{/if}

<style>
	.popup-container {
		width: 700px;
		height: 600px;
		background: var(--ui-bg-primary);
		border: 1px solid var(--ui-border);
		border-radius: 8px;
		display: flex;
		flex-direction: column;
		overflow: hidden;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
		position: fixed;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		z-index: 9999;
	}
	.span-container {
		display: felx;
		flex-direction: column;
		gap: 8px;
		width: 100%;
	}
	.span-container span {
		align-items: top;
		display: block;
		flex-direction: row;
		width: 100%;
		font-size: 30px;
	}
	.span-row {
		/* Each row is a flex container, left label and right value */
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		/* optionally align items on the baseline or center */
		align-items: baseline;
	}

	.span-row span {
		/* Let it inherit the global font instead of forcing a size */
		font-size: inherit;
	}

	.header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 8px 12px;
		border-bottom: 1px solid var(--ui-border);
		height: 40px;
	}

	.title {
		font-size: 16px;
		font-weight: 500;
		color: var(--text-primary);
	}

	.search-bar {
		padding: 8px 12px;
		display: flex;
		align-items: center;
		gap: 8px;
		border-bottom: 1px solid var(--ui-border);
		height: 48px;
		position: relative;
	}

	.search-bar input {
		flex: 1;
		background: var(--ui-bg-element);
		border: 1px solid var(--ui-border);
		padding: 6px 10px;
		color: var(--text-primary);
		border-radius: 4px;
	}

	.search-icon {
		color: var(--text-secondary);
	}

	.filters {
		padding: 4px 8px;
		display: flex;
		gap: 4px;
		flex-wrap: wrap;
		border-bottom: 1px solid var(--ui-border);
		height: auto;
		max-height: 80px;
		overflow-y: auto;
	}

	.filter-bubble {
		background: transparent;
		border: 1px solid var(--ui-border);
		color: var(--text-secondary);
		padding: 2px 8px;
		border-radius: 8px;
		font-size: 10px;
		cursor: pointer;
		transition: all 0.2s;
	}

	.filter-bubble.active {
		background: var(--ui-accent);
		border-color: var(--ui-accent);
		color: var(--text-primary);
	}

	.content-container {
		flex: 1;
		overflow-y: auto;
		padding: 12px;
	}

	.field-select {
		display: flex;
		align-items: center;
		gap: 8px;
		margin-left: auto;
	}

	.field-select span {
		color: var(--text-secondary);
		font-size: 14px;
	}
	
	.loading-spinner {
		width: 30px;
		height: 30px;
		border: 3px solid var(--ui-border);
		border-top: 3px solid var(--text-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-bottom: 10px;
	}
	.security-item {
		display: flex;
		align-items: center;
		padding: 8px 12px;
		cursor: pointer;
		border-bottom: 1px solid var(--ui-border);
		height: 40px;
	}

	.security-item:hover {
		background: var(--ui-bg-hover);
	}

	.security-icon {
		margin-right: 12px;
		width: 24px;
		height: 24px;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.security-icon img {
		width: 28px;
		height: 28px;
		object-fit: contain;
	}

	.security-info {
		flex: 1;
		display: flex;
		flex-direction: row;
		align-items: center;
		gap: 12px;
	}

	.security-main {
		display: flex;
		align-items: center;
		gap: 8px;
		flex: 1;
	}

	.ticker {
		font-weight: 600;
		color: var(--text-primary);
		min-width: 60px;
		font-size: 0.9em;
	}

	.name {
		color: var(--text-secondary);
		font-size: 0.85em;
		flex: 1;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.security-details {
		display: flex;
		align-items: center;
		gap: 8px;
		flex: 1;
		color: var(--text-secondary);
		font-size: 0.8em;
		margin-left: auto;
	}

	.sector {
		color: var(--text-secondary);
		font-size: 0.8em;
		margin-right: 8px;
	}

	.exchange {
		color: var(--text-secondary);
		font-size: 0.8em;
		min-width: 50px;
	}

	.date {
		color: var(--text-secondary);
		align-items: center;
		justify-content: center;
		padding: 20px;
	}
</style>


<file>/home/aj/dev/study/frontend/src/lib/utils/popups/input.svelte</file>
<!-- instance.svelte -->
<script lang="ts" context="module">
	import '$lib/core/global.css';
	import { privateRequest } from '$lib/core/backend';
	import { get, writable } from 'svelte/store';
	import { parse } from 'date-fns';
	import { tick } from 'svelte';
	import type { Writable } from 'svelte/store';
	import type { Instance } from '$lib/core/types';

	/**
	 * Simplified Focus Management Strategy:
	 * 1. When input component is activated, we store the previously focused element
	 * 2. We focus the input window itself and handle keyboard events directly
	 * 3. When input is completed or cancelled, we restore focus to the previously focused element
	 * 4. We clean up all event listeners when the component is destroyed or deactivated
	 */

	const allKeys = ['ticker', 'timestamp', 'timeframe', 'extendedHours', 'price'] as const;
	let currentSecurityResultRequest = 0;

	type InstanceAttributes = (typeof allKeys)[number];
	let filterOptions = [];
	let loadedSecurityResultRequest = -1;
	privateRequest<[]>('getSecurityClassifications', {}).then((v: []) => {
		filterOptions = v;
	});
	interface InputQuery {
		// 'inactive': no UI shown
		// 'initializing' setting up event handlers
		// 'active': window is open waiting for input
		// 'complete': one field completed (may still be active if more required)
		// 'cancelled': user cancelled via Escape
		// 'shutdown': about to close and reset to inactive
		status: 'inactive' | 'initializing' | 'active' | 'complete' | 'cancelled' | 'shutdown';
		inputString: string;
		inputType: string;
		inputValid: boolean;
		instance: Instance;
		requiredKeys: InstanceAttributes[] | 'any';
		possibleKeys: InstanceAttributes[];
		securities?: Instance[];
	}

	const inactiveInputQuery: InputQuery = {
		status: 'inactive',
		inputString: '',
		inputValid: true,
		inputType: '',
		requiredKeys: 'any',
		possibleKeys: [],
		instance: {}
	};
	export const inputQuery: Writable<InputQuery> = writable({ ...inactiveInputQuery });

	// Hold the reject function of the currently active promise (if any)
	let activePromiseReject: ((reason?: any) => void) | null = null;

	// Modified queryInstanceInput: if called while another query is active,
	// cancel the previous query (rejecting its promise) and reset the state.
	export async function queryInstanceInput(
		requiredKeys: InstanceAttributes[] | 'any',
		optionalKeys: InstanceAttributes[] | 'any',
		instance: Instance = {}
	): Promise<Instance> {
		// If an input query is already active, force its cancellation.
		if (get(inputQuery).status !== 'inactive') {
			if (activePromiseReject) {
				activePromiseReject(new Error('User cancelled input'));
				activePromiseReject = null;
			}
			inputQuery.update((q) => ({ ...inactiveInputQuery }));
			// Optionally wait a tick for the UI to update.
			await tick();
		}

		// Determine possible keys.
		let possibleKeys: InstanceAttributes[];
		if (optionalKeys === 'any') {
			possibleKeys = [...allKeys];
		} else {
			possibleKeys = Array.from(
				new Set([...requiredKeys, ...optionalKeys])
			) as InstanceAttributes[];
		}
		await tick();

		// Check if there's an initial inputString in the instance
		const initialInputString =
			'inputString' in instance && instance['inputString'] != null
				? String(instance['inputString'])
				: '';
		// Remove inputString property (not part of the Instance interface)
		if ('inputString' in instance) {
			const instanceAny = instance as any;
			delete instanceAny.inputString;
		}

		// Initialize the query with passed instance info.
		inputQuery.update((v: InputQuery) => ({
			...v,
			requiredKeys,
			possibleKeys,
			instance,
			inputString: initialInputString, // Use the initial input string if provided
			status: 'initializing'
		}));

		// Return a new promise that resolves when input is complete or rejects on cancellation.
		return new Promise<Instance>((resolve, reject) => {
			// Save the reject function so a subsequent call can cancel this query.
			activePromiseReject = reject;

			const unsubscribe = inputQuery.subscribe((iQ: InputQuery) => {
				if (iQ.status === 'cancelled') {
					cleanup();
					reject(new Error('User cancelled input'));
				} else if (iQ.status === 'complete') {
					const result = iQ.instance;
					cleanup();
					resolve(result);
				}
			});

			function cleanup() {
				unsubscribe();
				activePromiseReject = null;
				// Trigger a shutdown to reset state.
				inputQuery.update((v: InputQuery) => ({ ...v, status: 'shutdown' }));
			}
		});
	}
</script>

<script lang="ts">
	import { browser } from '$app/environment';
	import { onDestroy, onMount } from 'svelte';
	import { ESTStringToUTCTimestamp, UTCTimestampToESTString } from '$lib/core/timestamp';
	
	// Track the previously focused element
	let prevFocusedElement: HTMLElement | null = null;
	let inputWindowElement: HTMLDivElement;
	let isLoadingSecurities = false;
	let manualInputType: string = 'auto';

	// Add this reactive statement
	$: if (manualInputType !== 'auto' && $inputQuery.status === 'active') {
		inputQuery.update((v) => ({
			...v,
			inputType: manualInputType
		}));
	}

	interface ValidateResponse {
		inputValid: boolean;
		securities: Instance[];
	}

	async function validateInput(inputString: string, inputType: string): Promise<ValidateResponse> {
		if (inputType === 'ticker') {
			isLoadingSecurities = true;
			try {
				const securities = await privateRequest<Instance[]>('getSecuritiesFromTicker', {
					ticker: inputString
				});
				if (Array.isArray(securities) && securities.length > 0) {
					return {
						inputValid: true,
						securities: securities
					};
				}
				return { inputValid: false, securities: [] };
			} finally {
				isLoadingSecurities = false;
			}
		} else if (inputType === 'timeframe') {
			const regex = /^\d{1,3}[yqmwhds]?$/i;
			return { inputValid: regex.test(inputString), securities: [] };
		} else if (inputType === 'timestamp') {
			const formats = ['yyyy-MM-dd H:m:ss', 'yyyy-MM-dd H:m', 'yyyy-MM-dd H', 'yyyy-MM-dd'];
			for (const format of formats) {
				try {
					const parsedDate = parse(inputString, format, new Date());
					if (!isNaN(parsedDate.getTime())) {
						return { inputValid: true, securities: [] };
					}
				} catch {
					/* try next format */
				}
			}
			return { inputValid: false, securities: [] };
		} else if (inputType === 'price') {
			const price = parseFloat(inputString);
			return { inputValid: !isNaN(price) && price > 0, securities: [] };
		}
		return { inputValid: false, securities: [] };
	}

	async function waitForSecurityResult(): Promise<void> {
		return new Promise((resolve) => {
			const check = () => {
				if (loadedSecurityResultRequest === currentSecurityResultRequest) {
					resolve();
				} else {
					// Check again after 50ms (or adjust as needed)
					setTimeout(check, 50);
				}
			};
			check();
		});
	}

	async function enterInput(iQ: InputQuery, tickerIndex: number = 0): Promise<InputQuery> {
		if (iQ.inputType === 'ticker') {
			const ts = iQ.instance.timestamp;
			await waitForSecurityResult();
			iQ = $inputQuery;
			if (Array.isArray(iQ.securities) && iQ.securities.length > 0) {
				iQ.instance = { ...iQ.instance, ...iQ.securities[tickerIndex] };
				iQ.instance.timestamp = ts;
			}
		} else if (iQ.inputType === 'timeframe') {
			iQ.instance.timeframe = iQ.inputString;
		} else if (iQ.inputType === 'timestamp') {
			iQ.instance.timestamp = ESTStringToUTCTimestamp(iQ.inputString);
		} else if (iQ.inputType === 'price') {
			iQ.instance.price = parseFloat(iQ.inputString);
		}
		// Mark as complete but then check if further input is needed.
		iQ.status = 'complete';
		if (iQ.requiredKeys === 'any') {
			if (Object.keys(iQ.instance).length === 0) {
				iQ.status = 'active';
			}
		} else {
			for (const attribute of iQ.requiredKeys) {
				if (!iQ.instance[attribute]) {
					iQ.status = 'active';
					break;
				}
			}
		}
		iQ.inputString = '';
		iQ.inputType = '';
		iQ.inputValid = true;
		// Reset manualInputType to auto after input is entered
		manualInputType = 'auto';
		return iQ;
	}

	// Handle keyboard input directly on the input window
	async function handleKeyDown(event: KeyboardEvent): Promise<void> {
		// Get current state directly from the store to ensure we have latest state
		const currentState = get(inputQuery);

		// Make sure we're in active state
		if (currentState.status !== 'active') {
			return;
		}

		// Always prevent default behavior for our captured keys to avoid browser handling
		if (
			event.key === 'Enter' ||
			event.key === 'Tab' ||
			event.key === 'Escape' ||
			/^[a-zA-Z0-9]$/.test(event.key) ||
			/[-:.]/.test(event.key) ||
			(event.key === ' ' && currentState.inputType === 'timestamp') ||
			event.key === 'Backspace'
		) {
			event.preventDefault();
		}

		// Stop propagation to prevent double-handling
		event.stopPropagation();

		let iQ = { ...currentState };
		if (event.key === 'Escape') {
			inputQuery.update((q) => ({ ...q, status: 'cancelled' }));
			return;
		} else if (event.key === 'Enter') {
			if (iQ.inputValid) {
				const updatedQuery = await enterInput(iQ, 0);
				inputQuery.set(updatedQuery);
			}
			return;
		} else if (event.key === 'Tab') {
			inputQuery.update((q) => ({
				...q,
				instance: { ...q.instance, extendedHours: !q.instance.extendedHours }
			}));
			return;
		}

		// Process input keys
		if (
			/^[a-zA-Z0-9]$/.test(event.key) ||
			/[-:.]/.test(event.key) ||
			(event.key === ' ' && iQ.inputType === 'timestamp')
		) {
			// Transform the key based on input type
			const key = iQ.inputType === 'timeframe' ? event.key : event.key.toUpperCase();
			const newInputString = iQ.inputString + key;

			// Update inputString immediately
			inputQuery.update((v) => ({
				...v,
				inputString: newInputString
			}));

			// Then determine input type
			determineInputType(newInputString);
		} else if (event.key === 'Backspace') {
			const newInputString = iQ.inputString.slice(0, -1);

			// Update inputString immediately
			inputQuery.update((v) => ({
				...v,
				inputString: newInputString
			}));

			// Then determine input type
			determineInputType(newInputString);
		}
	}

	function determineInputType(inputString: string): void {
		const iQ = get(inputQuery);
		let inputType = iQ.inputType;

		// Only auto-classify if manualInputType is set to 'auto'
		if (manualInputType === 'auto') {
			if (inputString !== '') {
				if (iQ.possibleKeys.includes('ticker') && /^[A-Z]$/.test(inputString)) {
					inputType = 'ticker';
				} else if (iQ.possibleKeys.includes('price') && /^(?:\d*\.\d+|\d{3,})$/.test(inputString)) {
					inputType = 'price';
				} else if (
					iQ.possibleKeys.includes('timeframe') &&
					/^\d{1,2}[hdwmqs]?$/i.test(inputString)
				) {
					inputType = 'timeframe';
				} else if (iQ.possibleKeys.includes('timestamp') && /^[\d-]+$/.test(inputString)) {
					inputType = 'timestamp';
				} else if (iQ.possibleKeys.includes('ticker')) {
					inputType = 'ticker';
				} else {
					inputType = '';
				}
			} else {
				inputType = '';
			}
		} else {
			// Use the manually selected input type
			inputType = manualInputType;
		}

		// Update the input type
		inputQuery.update((v) => ({
			...v,
			inputType
		}));

		// Trigger validation
		currentSecurityResultRequest++;
		const thisSecurityResultRequest = currentSecurityResultRequest;
		validateInput(inputString, inputType).then((validationResp: ValidateResponse) => {
			if (thisSecurityResultRequest === currentSecurityResultRequest) {
				inputQuery.update((v: InputQuery) => ({
					...v,
					...validationResp
				}));
				loadedSecurityResultRequest = thisSecurityResultRequest;
			}
		});
	}

	// Handle clicks outside the popup to close it
	function handleOutsideClick(event: MouseEvent) {
		const inputWindow = document.getElementById('input-window');
		if (!inputWindow || !inputWindow.contains(event.target as Node)) {
			inputQuery.update((v) => ({ ...v, status: 'cancelled' }));
		}
	}

	function closeWindow() {
		inputQuery.update((v) => ({ ...v, status: 'cancelled' }));
	}

	let sectors: string[] = [];
	let industries: string[] = [];
	function capitalize(str: string, lower = false): string {
		return (lower ? str.toLowerCase() : str).replace(/(?:^|\s|["'([{])+\S/g, (match: string) =>
			match.toUpperCase()
		);
	}

	function formatTimeframe(timeframe: string): string {
		const match = timeframe.match(/^(\d+)([dwmsh]?)$/i) ?? null;
		let result = timeframe;
		if (match) {
			switch (match[2]) {
				case 'd':
					result = `${match[1]} days`;
					break;
				case 'w':
					result = `${match[1]} weeks`;
					break;
				case 'm':
					result = `${match[1]} months`;
					break;
				case 'h':
					result = `${match[1]} hours`;
					break;
				case 's':
					result = `${match[1]} seconds`;
					break;
				default:
					result = `${match[1]} minutes`;
					break;
			}
			if (match[1] === '1') {
				result = result.slice(0, -1);
			}
		}
		return result;
	}

	onMount(() => {
		// Store the currently focused element
		prevFocusedElement = document.activeElement as HTMLElement;

		const unsubscribe = inputQuery.subscribe((v: InputQuery) => {
			if (browser) {
				if (v.status === 'initializing') {
					// Store focused element before showing the popup
					prevFocusedElement = document.activeElement as HTMLElement;
                    
                    // Mark the UI as active now
                    inputQuery.update((state) => ({ ...state, status: 'active' }));
                    
                    // Focus the input window after it renders
                    tick().then(() => {
                        // Focus the input window itself (will receive keyboard events)
                        if (inputWindowElement) {
                            inputWindowElement.focus();
                        }
                        
                        // Add a click handler to the document to detect clicks outside the popup
                        document.addEventListener('mousedown', handleOutsideClick);
                    });
				} else if (v.status === 'shutdown' || v.status === 'cancelled') {
					// Remove document click handler
					document.removeEventListener('mousedown', handleOutsideClick);
					
					// Restore focus to the previously focused element
					if (prevFocusedElement) {
                        tick().then(() => {
                            prevFocusedElement?.focus();
                            
                            if (v.status === 'shutdown') {
                                // Reset to inactive only after focus is restored
                                inputQuery.update((state) => ({ ...state, status: 'inactive', inputString: '' }));
                            }
                        });
					} else if (v.status === 'shutdown') {
                        // Reset to inactive if there was no previous element
                        inputQuery.update((state) => ({ ...state, status: 'inactive', inputString: '' }));
                    }
				}
			}
		});

		type SecurityClassifications = {
			sectors: string[];
			industries: string[];
		};
		privateRequest<SecurityClassifications>('getSecurityClassifications', {}, false).then(
			(classifications: SecurityClassifications) => {
				sectors = classifications.sectors;
				industries = classifications.industries;
			}
		);
		
		return () => {
			unsubscribe();
		};
	});

	onDestroy(() => {
		// Clean up any remaining event listeners
		document.removeEventListener('mousedown', handleOutsideClick);
	});
	
	function displayValue(q: InputQuery, key: string): string {
		if (key === q.inputType) {
			return q.inputString;
		} else if (key in q.instance) {
			if (key === 'timestamp') {
				return UTCTimestampToESTString(q.instance.timestamp ?? 0);
			} else if (key === 'extendedHours') {
				return q.instance.extendedHours ? 'True' : 'False';
			} else if (key === 'price') {
				return '$' + String(q.instance.price);
			} else {
				return String(q.instance[key as keyof Instance]);
			}
		}
		return '';
	}
</script>

{#if $inputQuery.status === 'active' || $inputQuery.status === 'initializing'}
	<div
		class="popup-container"
		id="input-window"
		bind:this={inputWindowElement}
		tabindex="0"
		on:keydown={handleKeyDown}
	>
		<div class="header">
			<div class="title">{capitalize($inputQuery.inputType)} Input</div>
			<div class="field-select">
				<span class="label">Field:</span>
				<select
					class="default-select"
					bind:value={manualInputType}
					on:click|stopPropagation
					on:change|stopPropagation
				>
					<option value="auto">Auto</option>
					{#each $inputQuery.possibleKeys as key}
						<option value={key}>{capitalize(key)}</option>
					{/each}
				</select>
			</div>
			<button class="utility-button" on:click|stopPropagation={closeWindow}>×</button>
		</div>

		<div class="search-bar">
			<input type="text" placeholder="Enter Value" value={$inputQuery.inputString} readonly />
		</div>
		<div class="content-container">
			{#if $inputQuery.instance && Object.keys($inputQuery.instance).length > 0}
				{#if $inputQuery.inputType === ''}
					<div class="span-container">
						{#each $inputQuery.possibleKeys as key}
							<div class="span-row">
								<span
									class={$inputQuery.requiredKeys !== 'any' &&
									$inputQuery.requiredKeys.includes(key) &&
									!$inputQuery.instance[key]
										? 'red'
										: ''}
								>
									{capitalize(key)}
								</span>
								<span class="value">
									{displayValue($inputQuery, key)}
								</span>
							</div>
						{/each}
					</div>
				{:else if $inputQuery.inputType === 'ticker'}
					<div class="table-container">
						{#if isLoadingSecurities}
							<div class="loading-container">
								<div class="loading-spinner"></div>
								<span class="label">Loading securities...</span>
							</div>
						{:else if Array.isArray($inputQuery.securities) && $inputQuery.securities.length > 0}
							<table>
								<tbody>
									{#each $inputQuery.securities as sec, i}
										<tr
											on:click={async () => {
												const updatedQuery = await enterInput($inputQuery, i);
												inputQuery.set(updatedQuery);
											}}
										>
											<td class="defalt-td">
												<div
													style="background-color: transparent; width: 100px; height: 30px; display: flex; align-items: center; justify-content: center;"
												>
													{#if sec.icon}
														<img
															src={`data:image/jpeg;base64,${sec.icon}`}
															alt="Security Image"
															style="max-width: 100%; max-height: 100%; object-fit: contain;"
														/>
													{/if}
												</div>
											</td>
											<td class="defalt-td">{sec.ticker}</td>
											<td class="defalt-td">{sec.name}</td>
											<td class="defalt-td"
												>{sec.timestamp !== undefined
													? UTCTimestampToESTString(sec.timestamp)
													: ''}</td
											>
										</tr>
									{/each}
								</tbody>
							</table>
						{/if}
					</div>
				{:else if $inputQuery.inputType === 'timestamp'}
					<div class="span-container">
						<div class="span-row">
							<span class="label">Timestamp</span>
							<input
								type="datetime-local"
								on:change={(e) => {
									// Use type casting in a different way that works better with Svelte compiler
									const target = e.target;
									const inputValue = target && 'value' in target ? String(target.value) : '';
									const date = new Date(inputValue);
									inputQuery.update((q) => ({
										...q,
										instance: {
											...q.instance,
											timestamp: !isNaN(date.getTime()) ? date.getTime() : q.instance.timestamp
										},
										inputValid: !isNaN(date.getTime())
									}));
								}}
							/>
						</div>
					</div>
				{:else if $inputQuery.inputType === 'timeframe'}
					<div class="span-container">
						<div class="span-row">
							<span class="label">Timeframe</span>
							<span class="value">{formatTimeframe($inputQuery.inputString)}</span>
						</div>
					</div>
				{:else if $inputQuery.inputType === 'extendedHours'}
					<div class="span-container">
						<div class="span-row">
							<span class="label">Extended Hours</span>
							<span class="value">{$inputQuery.instance.extendedHours ? 'True' : 'False'}</span>
						</div>
					</div>
					0
				{/if}
			{/if}
		</div>
	</div>
{/if}

<style>
	.popup-container {
		width: 700px;
		height: 600px;
		background: var(--ui-bg-primary);
		border: 1px solid var(--ui-border);
		border-radius: 8px;
		display: flex;
		flex-direction: column;
		overflow: hidden;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
		position: fixed;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		z-index: 9999;
	}
	.span-container {
		display: felx;
		flex-direction: column;
		gap: 8px;
		width: 100%;
	}
	.span-container span {
		align-items: top;
		display: block;
		flex-direction: row;
		width: 100%;
		font-size: 30px;
	}
	.span-row {
		/* Each row is a flex container, left label and right value */
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		/* optionally align items on the baseline or center */
		align-items: baseline;
	}

	.span-row span {
		/* Let it inherit the global font instead of forcing a size */
		font-size: inherit;
	}

	.header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 8px 12px;
		border-bottom: 1px solid var(--ui-border);
		height: 40px;
	}

	.title {
		font-size: 16px;
		font-weight: 500;
		color: var(--text-primary);
	}

	.search-bar {
		padding: 8px 12px;
		display: flex;
		align-items: center;
		gap: 8px;
		border-bottom: 1px solid var(--ui-border);
		height: 48px;
		position: relative;
	}

	.search-bar input {
		flex: 1;
		background: var(--ui-bg-element);
		border: 1px solid var(--ui-border);
		padding: 6px 10px;
		color: var(--text-primary);
		border-radius: 4px;
	}

	.search-icon {
		color: var(--text-secondary);
	}

	.filters {
		padding: 4px 8px;
		display: flex;
		gap: 4px;
		flex-wrap: wrap;
		border-bottom: 1px solid var(--ui-border);
		height: auto;
		max-height: 80px;
		overflow-y: auto;
	}

	.filter-bubble {
		background: transparent;
		border: 1px solid var(--ui-border);
		color: var(--text-secondary);
		padding: 2px 8px;
		border-radius: 8px;
		font-size: 10px;
		cursor: pointer;
		transition: all 0.2s;
	}

	.filter-bubble.active {
		background: var(--ui-accent);
		border-color: var(--ui-accent);
		color: var(--text-primary);
	}

	.content-container {
		flex: 1;
		overflow-y: auto;
		padding: 12px;
	}

	.field-select {
		display: flex;
		align-items: center;
		gap: 8px;
		margin-left: auto;
	}

	.field-select span {
		color: var(--text-secondary);
		font-size: 14px;
	}
	
	.loading-spinner {
		width: 30px;
		height: 30px;
		border: 3px solid var(--ui-border);
		border-top: 3px solid var(--text-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-bottom: 10px;
	}
	.security-item {
		display: flex;
		align-items: center;
		padding: 8px 12px;
		cursor: pointer;
		border-bottom: 1px solid var(--ui-border);
		height: 40px;
	}

	.security-item:hover {
		background: var(--ui-bg-hover);
	}

	.security-icon {
		margin-right: 12px;
		width: 24px;
		height: 24px;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.security-icon img {
		width: 28px;
		height: 28px;
		object-fit: contain;
	}

	.security-info {
		flex: 1;
		display: flex;
		flex-direction: row;
		align-items: center;
		gap: 12px;
	}

	.security-main {
		display: flex;
		align-items: center;
		gap: 8px;
		flex: 1;
	}

	.ticker {
		font-weight: 600;
		color: var(--text-primary);
		min-width: 60px;
		font-size: 0.9em;
	}

	.name {
		color: var(--text-secondary);
		font-size: 0.85em;
		flex: 1;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.security-details {
		display: flex;
		align-items: center;
		gap: 8px;
		flex: 1;
		color: var(--text-secondary);
		font-size: 0.8em;
		margin-left: auto;
	}

	.sector {
		color: var(--text-secondary);
		font-size: 0.8em;
		margin-right: 8px;
	}

	.exchange {
		color: var(--text-secondary);
		font-size: 0.8em;
		min-width: 50px;
	}

	.date {
		color: var(--text-secondary);
		align-items: center;
		justify-content: center;
		padding: 20px;
	}
</style>


<file>../broker/services/frontend/src/routes/app/chart.svelte</file>
<!-- chart.svelte -->
<script>
	import { onMount } from "svelte";
	import { chart } from "../../chart/chart.js";
	import {toDT, chartQuery, setups_list,menuLeftPos,  request , currentEntry} from "../../store.js";
	let innerWidth, canvas, innerHeight, Chart, queryLabel,  selectedT, selectedPrice, selectedMenuAction, clickX, clickY;
    let chartMenuVisible = false;
    let chartFocused = true;
	let queryError = "";
    let queryValue = "";
    import { get } from 'svelte/store';

    function handleChartClick(event) {
        chartFocused = true;
        chartMenuVisible = false;
        selectedMenuAction = null;
    }
    function updateChartSize(v) {
        if (!canvas) {
            return;
        }
        canvas.width = v;
        canvas.height = window.innerHeight;
        Chart.draw();
    }
    function handleWindowClick(event) {
        if (!canvas.contains(event.target)) {
            chartMenuVisible = false;
            chartFocused = false;
            queryValue = "";
            queryLabel = null;
            queryError = "";
        }
    }
    function handleRightClick(event) {
        if (!Chart.queryValid) return;
        clickX = event.clientX - canvas.getBoundingClientRect().left;
        clickY = event.clientY - canvas.getBoundingClientRect().top;
        chartMenuVisible = true;
        selectedT = Chart.currentT;
        selectedPrice = Chart.currentPrice;
    }

	onMount(() => {
		Chart = new chart(canvas, {
            margin: 20,
            defaultCandleWidth: 10,
        });
        menuLeftPos.subscribe((v) => updateChartSize(v));
        chartQuery.subscribe((v) => {Chart.updateQuery(v[0],v[1],v[2],v[3]);});
        window.addEventListener("resize", updateChartSize);
        window.addEventListener("click", handleWindowClick);
        canvas.addEventListener("contextmenu", (event) => {event.preventDefault();handleRightClick(event);});
        canvas.addEventListener("click", handleChartClick);
        chartQuery.set(["MSTR","1d",null,false])
        return () => {
            window.removeEventListener("click", handleWindowClick);
            window.removeEventListener("resize", updateChartSize);
            canvas.removeEventListener("click", handleChartClick);
        };
    });

    function classifyInput(input){
        if (queryValue) {
        return /^[0-9]$/.test(input[0]) ? "Interval" : "Ticker";
        }else{
            return null;
        }
    }



	function onKeydown(event) {
        if (!chartFocused) return;
        chartMenuVisible = false;
		if (/^[a-zA-Z0-9]$/.test(event.key.toLowerCase())) {
            console.log(queryValue);
            queryError = ""
			queryValue += event.key;
            queryLabel = classifyInput(queryValue);
		}else if (event.key == "Backspace") {
            queryValue = queryValue.slice(0, -1);
            queryLabel = classifyInput(queryValue);
        }else if (event.key == "Escape") {
            queryValue = "";
            queryLabel = null;
            queryError = "";
        }
        else if (event.key == "Enter") {
            switch (queryLabel) {
                case "Ticker":
                    chartQuery.update((v) => {return ([queryValue.toUpperCase(),v[1],v[2],v[3]])});
                    break;
                case "Interval":
                    chartQuery.update((v) => {return ([v[0],queryValue,v[2],v[3]])});
                    break;
                case "Date":
                    break;
                case null:
                    queryError = "Invalid Input";
                    break;
            }
			queryValue = "";
		}
	}
</script>


<canvas bind:this={canvas} class="chart-container"></canvas>
<svelte:window on:keydown={onKeydown} bind:innerWidth bind:innerHeight />

{#if chartMenuVisible}
    <div class="menu" style="top: {clickY}px; left: {clickX}px;">
        <p>Add {`${Chart.ticker} ${toDT(selectedT)}`} to ...</p>
        <button on:click={() => {selectedMenuAction = "newAnnotation"; chartMenuVisible = false}}>Annotate</button>
        <button on:click={() => {currentEntry.update((e) => `${e} [${Chart.ticker}|${Chart.i}|${selectedT}|${Chart.pm}] `)}}>Entry</button>
    </div>
{/if}
{#if selectedMenuAction}
    <div class="menu" style="top: {clickY}px; left: {clickX}px;">
        {#each $setups_list as setup}
            <button on:click={() => {request(null,true,selectedMenuAction,Chart.ticker,setup[0],selectedT); selectedMenuAction = null; chartMenuVisible = false}}>{setup[1]}</button>
        {/each}
    </div>
{/if}

{#if queryValue}
    <div class="query">
        <div class="value">{queryValue}</div>
        <div class="label">{queryLabel}</div>
    </div>
{/if}
{#if queryError}
    <div class="queryError">
        {queryError}
    </div>
{/if}

<style>
    @import "../../global.css";
    .chart-container {
        background-color: black;
        width: 100%;
        height: 100%;
        /*flex-grow: 1;*/

    }
	.menu {
        position: absolute;
        color: white; 
        background-color: var(--c2); 
        padding: 10px; 
        border-radius: 5px; 
        text-align: left; 
        box-sizing: border-box;
        z-index: 1000;
        font-size: 16px; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); 
        font-family: Arial, sans-serif; 
        border: 2px solid var(--c3); 
    }

    .menu button {
        display: block; 
        margin: 5px 0; 
        background-color: var(--c1); 
        color: var(--f1); 
        border: none;
        border-radius: 4px;
        padding: 10px 20px;
        text-align: left; 
        width: 100%; 
        box-sizing: border-box; 
        transition: background-color 0.3s; 
        cursor: pointer; 
    }

    .menu button:hover {
        background-color: #505760; 
    }

    .query {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--c2); 
        border: 2px solid var(--c3);
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        box-sizing: border-box;
        z-index: 2000;
        font-size: 16px; 
        color: var(--f1);
        font-family: Arial, sans-serif; 
        text-transform: uppercase; 
    }
    .value {
        font-size: 16pt; 
    }
    .label {
        margin-top: 10px; 
        font-size: 14pt; 
    }
    .queryError {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10000;
        color: var(--c4);
        background-color: #FFD2D2;
        padding: 20px 40px;
        border-radius: 10px;
        border: 2px solid #D8000C;
        box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.7);
        font-size: 20px;
        font-weight: bold;
        text-align: center;
        max-width: 600px;
        word-wrap: break-word;
        box-sizing: border-box;
    }
</style>


<file>../study/frontend/src/lib/features/chart/chartContainer.svelte</file>
<script lang="ts">
	import Chart from './chart.svelte';
	import { settings } from '$lib/core/stores';
	import { onMount, tick } from 'svelte';
	import { get } from 'svelte/store';
	import { queryInstanceInput } from '$lib/utils/popups/input.svelte';
	import { queryChart } from './interface';
	export let width: number;

	// Add focus management
	let containerRef: HTMLDivElement;

	onMount(() => {
		// Focus the chart container immediately after it's mounted
		if (containerRef) {
			containerRef.focus();
		}

		// Add global keyboard event listener for chart container
		const handleGlobalKeydown = (event: KeyboardEvent) => {
			// If an input popup is active, don't process keyboard input here
			const inputWindow = document.getElementById('input-window');
			if (inputWindow) {
				return;
			}

			// Only handle alphanumeric keys when no modal is active and no modifier keys are pressed
			if (
				/^[a-zA-Z0-9]$/.test(event.key) &&
				!event.ctrlKey &&
				!event.metaKey &&
				!event.altKey &&
				document.activeElement !== document.body // Don't interfere with other focused elements
			) {
				// Create an initial instance with the first key as the inputString
				const initialKey = event.key.toUpperCase();

				// Use type assertion to allow the inputString property
				const instanceWithInput = {
					inputString: initialKey
				} as any;

				queryInstanceInput(
					'any',
					['ticker', 'timeframe', 'timestamp', 'extendedHours'],
					instanceWithInput
				).then((updatedInstance) => {
					queryChart(updatedInstance, true);
					// Focus will be automatically restored to the chart by the input component
				});
			}
		};

		document.addEventListener('keydown', handleGlobalKeydown);

		return () => {
			document.removeEventListener('keydown', handleGlobalKeydown);
		};
	});

	// Handle focus management
	function handleKeyDown(event: KeyboardEvent) {
		if (event.key === 'Tab') {
			event.preventDefault(); // Prevent default tab behavior
		}
	}
</script>

<div
	class="chart-container"
	bind:this={containerRef}
	tabindex="0"
	role="application"
	aria-label="Chart Container"
	on:keydown={handleKeyDown}
>
	{#each Array.from({ length: $settings.chartRows }) as _, j}
		<div class="row" style="height: calc(100% / {$settings.chartRows})">
			{#each Array.from({ length: $settings.chartColumns }) as _, i}
				<Chart width={width / $settings.chartColumns} chartId={i + j * $settings.chartColumns} />
			{/each}
		</div>
	{/each}
</div>

<style>
	.chart-container {
		display: flex;
		flex-direction: column;
		width: 100%;
		height: 100%;
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		outline: none; /* Remove focus outline but maintain accessibility */
	}

	.row {
		display: flex;
		width: 100%;
		justify-content: space-between;
		flex: 1;
		min-height: 0;
	}
</style>


<file>../study/frontend/src/lib/features/watchlist.svelte</file>
<script lang="ts">
	import List from '$lib/utils/modules/list.svelte';
	import type { Writable } from 'svelte/store';
	import { writable, get } from 'svelte/store';
	import type { Instance, Watchlist } from '$lib/core/types';
	import { onMount, tick } from 'svelte';
	import { privateRequest } from '$lib/core/backend';
	import { queryInstanceInput } from '$lib/utils/popups/input.svelte';
	import { flagWatchlistId, watchlists, flagWatchlist } from '$lib/core/stores';
	import '$lib/core/global.css';

	let activeList: Writable<Instance[]> = writable([]);
	let newWatchlistName = '';
	let currentWatchlistId: number;
	let container: HTMLDivElement;
	let newNameInput: HTMLInputElement;
	let showWatchlistInput = false;
	let confirmingDelete = false;

	onMount(() => {
		selectWatchlist(flagWatchlistId);
	});

	function addInstance() {
		const inst = { ticker: '', timestamp: 0 };
		queryInstanceInput(['ticker'], ['ticker', 'timestamp'], inst).then((i: Instance) => {
			const aList = get(activeList);
			const empty = !Array.isArray(aList);
			if (empty || !aList.find((l: Instance) => l.ticker === i.ticker)) {
				privateRequest<number>('newWatchlistItem', {
					watchlistId: parseInt(currentWatchlistId, 10),
					securityId: i.securityId
				}).then((watchlistItemId: number) => {
					activeList.update((v: Instance[]) => {
						i.watchlistItemId = watchlistItemId;
						if (empty) {
							return [i];
						} else {
							return [...v, i];
						}
					});
				});
			}
			setTimeout(() => {
				addInstance();
			}, 1);
		});
	}

	function newWatchlist() {
		if (newWatchlistName === '') return;

		// Check for duplicate names
		const existingWatchlist = get(watchlists).find(
			(w) => w.watchlistName.toLowerCase() === newWatchlistName.toLowerCase()
		);

		if (existingWatchlist) {
			alert('A watchlist with this name already exists');
			return;
		}

		privateRequest<number>('newWatchlist', { watchlistName: newWatchlistName }).then(
			(newId: number) => {
				watchlists.update((v: Watchlist[]) => {
					const w: Watchlist = {
						watchlistName: newWatchlistName,
						watchlistId: newId
					};
					selectWatchlist(String(newId));
					newWatchlistName = '';
					showWatchlistInput = false;
					if (!Array.isArray(v)) {
						return [w];
					}
					return [w, ...v];
				});
			}
		);
	}

	function deleteItem(item: Instance) {
		if (!item.watchlistItemId) {
			throw new Error('missing id on delete');
		}
		privateRequest<void>('deleteWatchlistItem', { watchlistItemId: item.watchlistItemId }).then(
			() => {
				activeList.update((items) => {
					return items.filter((i) => i.watchlistItemId !== item.watchlistItemId);
				});
			}
		);
	}

	function selectWatchlist(watchlistIdString: string) {
		if (!watchlistIdString) return;

		if (watchlistIdString === 'new') {
			showWatchlistInput = true;
			tick().then(() => {
				newNameInput.focus();
			});
			return;
		}

		if (watchlistIdString === 'delete') {
			if (confirmingDelete) {
				deleteWatchlist(currentWatchlistId);
				confirmingDelete = false;
			} else {
				confirmingDelete = true;
				const watchlist = get(watchlists).find((w) => w.watchlistId === currentWatchlistId);
				if (!confirm(`Are you sure you want to delete "${watchlist?.watchlistName}"?`)) {
					selectWatchlist(String(currentWatchlistId));
					return;
				}
				deleteWatchlist(currentWatchlistId);
			}
			return;
		}

		showWatchlistInput = false;
		const watchlistId = parseInt(watchlistIdString);
		if (watchlistId === flagWatchlistId) {
			activeList = flagWatchlist;
		} else {
			activeList = writable<Instance[]>([]);
		}
		currentWatchlistId = watchlistId;
		privateRequest<Instance[]>('getWatchlistItems', { watchlistId: watchlistId }).then(
			(v: Instance[]) => {
				activeList.set(v);
			}
		);
	}

	function deleteWatchlist(id: number) {
		privateRequest<void>('deleteWatchlist', { watchlistId: id }).then(() => {
			watchlists.update((v: Watchlist[]) => {
				return v.filter((v: Watchlist) => v.watchlistId !== id);
			});
			if (id === flagWatchlistId) {
				flagWatchlist.set([]);
			}
		});
	}

	// Helper function to get first letter of watchlist name
	function getWatchlistInitial(name: string): string {
		return name.charAt(0).toUpperCase();
	}

	function handleWatchlistChange(event: Event) {
		const target = event.target as HTMLSelectElement;
		selectWatchlist(target.value);
	}
</script>

<div tabindex="-1" class="feature-container" bind:this={container}>
	<!-- Controls container first -->
	<div class="controls-container">
		{#if Array.isArray($watchlists)}
			<div class="watchlist-selector">
				<select
					class="default-select"
					id="watchlists"
					bind:value={currentWatchlistId}
					on:change={handleWatchlistChange}
				>
					<optgroup label="My Watchlists">
						{#each $watchlists as watchlist}
							<option value={watchlist.watchlistId}>
								{watchlist.watchlistName}
							</option>
						{/each}
					</optgroup>
					<optgroup label="Actions">
						<option value="new">+ Create New Watchlist</option>
						{#if currentWatchlistId}
							<option value="delete">- Delete Current Watchlist</option>
						{/if}
					</optgroup>
				</select>
				{#if !showWatchlistInput}
					<button class="utility-button" title="Add Symbol" on:click={addInstance}>+</button>
				{/if}
			</div>

			{#if showWatchlistInput}
				<div class="new-watchlist-container">
					<input
						class="input"
						bind:this={newNameInput}
						on:keydown={(event) => {
							if (event.key === 'Enter') {
								newWatchlist();
							} else if (event.key === 'Escape') {
								showWatchlistInput = false;
								selectWatchlist(String(currentWatchlistId));
							}
						}}
						bind:value={newWatchlistName}
						placeholder="New Watchlist Name"
					/>
					<div class="new-watchlist-buttons">
						<button class="utility-button" on:click={newWatchlist}>✓</button>
						<button
							class="utility-button"
							on:click={() => {
								showWatchlistInput = false;
								selectWatchlist(String(currentWatchlistId));
							}}>✕</button
						>
					</div>
				</div>
			{/if}
		{/if}
	</div>

	<!-- Shortcut buttons between controls and list -->
	<div class="shortcut-container">
		{#if Array.isArray($watchlists)}
			{#each $watchlists as watchlist}
				<button
					class="shortcut-button {currentWatchlistId === watchlist.watchlistId ? 'active' : ''}"
					on:click={() => selectWatchlist(String(watchlist.watchlistId))}
				>
					{getWatchlistInitial(watchlist.watchlistName)}
				</button>
			{/each}
		{/if}
	</div>

	<List
		parentDelete={deleteItem}
		columns={['Ticker', 'Price', 'Chg', 'Chg%', 'Ext']}
		list={activeList}
	/>
</div>

<style>
	.watchlist-selector {
		display: flex;
		align-items: center;
		gap: 8px;
	}

	.new-watchlist-container {
		margin-top: 8px;
		padding: 8px;
		background: var(--ui-bg-secondary);
		border-radius: 4px;
		border: 1px solid var(--ui-border);
	}

	.new-watchlist-container .input {
		width: 100%;
		margin-bottom: 8px;
	}

	.new-watchlist-buttons {
		display: flex;
		justify-content: flex-end;
		gap: 8px;
	}

	.shortcut-container {
		display: flex;
		gap: 8px;
		padding: 8px 8px 8px 16px;
		flex-wrap: wrap;
	}

	/* Ensure existing styles remain */
	.feature-container {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	/* Update existing style */
	.controls-container {
		display: flex;
		flex-direction: column;
		gap: 8px;
		padding: 8px 8px 8px 16px;
	}
</style>


</potential_codebase_context>
