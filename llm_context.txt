# Inputs

## Current File
Here is the file I'm looking at. It might be truncated from above and below and, if so, is centered around my cursor.
```list.svelte


```tasks/security.go


```quote.svelte



<potential_codebase_context>
## Potentially Relevant Code Snippets from the current Codebase

<file>frontend/src/lib/utils/modules/list.svelte</file>
<!-- screen.svelte -->
<script lang="ts">
	import { onMount, onDestroy } from 'svelte';
	import { writable, get } from 'svelte/store';
	import { UTCTimestampToESTString } from '$lib/core/timestamp';
	import type { Writable } from 'svelte/store';
	import type { Instance } from '$lib/core/types';
	import StreamCell from '$lib/utils/stream/streamCell.svelte';
	import { queryChart } from '$lib/features/chart/interface';
	import { flagWatchlist } from '$lib/core/stores';
	import { flagSecurity } from '$lib/utils/flag';
	import { newAlert } from '$lib/features/alerts/interface';
	import { queueRequest } from '$lib/core/backend';
	let longPressTimer: any;
	export let list: Writable<Instance[]> = writable([]);
	export let columns: Array<string>;
	export let parentDelete = (v: Instance) => {};
	export let formatters: { [key: string]: (value: any) => string } = {};
	export let expandable = false;
	export let expandedContent: (item: any) => any = () => null;
	export let displayNames: { [key: string]: string } = {};

	let selectedRowIndex = -1;
	let expandedRows = new Set();

	// Add these for similar trades handling
	let similarTradesMap = new Map();
	let loadingMap = new Map();
	let errorMap = new Map();

	let iconsMap = new Map();

	function isFlagged(instance: Instance, flagWatch: Instance[]) {
		if (!Array.isArray(flagWatch)) return false;
		return flagWatch.some((item) => item.ticker === instance.ticker);
	}

	function deleteRow(event: MouseEvent, watch: Instance) {
		event.stopPropagation();
		event.preventDefault();
		list.update((v: Instance[]) => {
			return v.filter((s) => s !== watch);
		});
		parentDelete(watch);
	}
	function createListAlert() {
		const alert = {
			price: get(list)[selectedRowIndex].price
		};
		for (let i = 0; i < get(list).length; i++) {
			alert.securityId = get(list)[i].securityId;
			alert.ticker = get(list)[i].ticker;
			newAlert(alert);
		}
	}
	function handleKeydown(event: KeyboardEvent, watch: Instance) {
		if (event.key === 'ArrowUp' || (event.key === ' ' && event.shiftKey)) {
			event.preventDefault();
			moveUp();
		} else if (event.key === 'ArrowDown' || event.key === ' ') {
			event.preventDefault();
			moveDown();
		} else {
			return;
		}
	}
	function moveDown() {
		if (selectedRowIndex < $list.length - 1) {
			selectedRowIndex++;
		} else {
			selectedRowIndex = 0;
		}
		scrollToRow(selectedRowIndex);
	}
	function moveUp() {
		if (selectedRowIndex > 0) {
			selectedRowIndex--;
		} else {
			selectedRowIndex = $list.length - 1;
		}
		scrollToRow(selectedRowIndex);
	}

	function scrollToRow(index: number) {
		const row = document.getElementById(`row-${index}`);
		if (row) {
			row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
			queryChart(get(list)[selectedRowIndex]);
		}
	}
	onMount(async () => {
		window.addEventListener('keydown', handleKeydown);
		const preventContextMenu = (event) => {
			event.preventDefault();
		};

		window.addEventListener('contextmenu', preventContextMenu);

		// Fetch icons if "Ticker" column is present
		if (columns.includes('Ticker')) {
			const tickers = get(list).map((item) => item.ticker);
			const iconsResponse = await privateRequest('getIcons', { tickers });
			iconsResponse.forEach((iconData) => {
				iconsMap.set(iconData.ticker, iconData.icon);
			});
		}

		return () => {
			window.removeEventListener('contextmenu', preventContextMenu);
		};
	});
	onDestroy(() => {
		window.removeEventListener('keydown', handleKeydown);
	});
	function clickHandler(
		event: MouseEvent,
		instance: Instance,
		index: number,
		force: number | null = null
	) {
		let even;
		if (force !== null) {
			even = force;
		} else {
			even = event.button;
		}
		console.log(event);
		event.preventDefault();
		event.stopPropagation();
		if (even === 0) {
			selectedRowIndex = index;
			if ('openQuantity' in instance) {
				queryChart(instance);
			} else {
				queryChart(instance);
			}
		} else if (even === 1) {
			flagSecurity(instance);
		}
	}
	function handleTouchStart(event, watch, i) {
		longPressTimer = setTimeout(() => {
			clickHandler(event, watch, i, 2); // The action you want to trigger
		}, 600); // Time in milliseconds to consider a long press
	}

	function handleTouchEnd() {
		clearTimeout(longPressTimer); // Clear if it's a short tap
	}

	function toggleRow(index: number) {
		console.log('Toggling row:', index);
		if (expandedRows.has(index)) {
			expandedRows.delete(index);
		} else {
			expandedRows.add(index);
			// Debug log for expanded content
			const content = expandedContent($list[index]);
			console.log('Expanded content:', content);
		}
		expandedRows = expandedRows; // Trigger reactivity
	}

	function formatValue(value: any, column: string): string {
		// Convert column name to camelCase
		const normalizedCol = column
			.replace(/ /g, '') // Remove spaces
			.replace(/^[A-Z]/, (letter) => letter.toLowerCase()); // Decapitalize first letter

		// Get the actual data property name based on the display column name
		let dataKey = normalizedCol;
		switch (normalizedCol) {
			case 'chg':
				dataKey = 'change';
				break;
			case 'chg%':
				dataKey = 'change%';
				break;
			case 'ext':
				dataKey = 'change%extended';
				break;
			default:
				dataKey = normalizedCol;
		}

		// Get value using the normalized data key
		const rawValue = value[dataKey];

		if (formatters[column]) {
			return formatters[column](rawValue);
		}
		return rawValue?.toString() ?? 'N/A';
	}

	function getAllOrders(trade) {
		return trade.trades || [];
	}

	async function loadSimilarTrades(tradeId: number) {
		if (!tradeId) {
			console.log('No tradeId provided');
			return;
		}

		console.log('Loading similar trades for trade:', tradeId);
		loadingMap.set(tradeId, true);
		errorMap.delete(tradeId);
		similarTradesMap = similarTradesMap;

		try {
			console.log('Making request for trade:', tradeId);
			const result = await queueRequest('find_similar_trades', { trade_id: tradeId });
			console.log('Similar trades result:', result);

			if (result.status === 'success') {
				similarTradesMap.set(tradeId, result.similar_trades);
				console.log('Updated similarTradesMap:', similarTradesMap);
			} else {
				errorMap.set(tradeId, result.message);
				console.log('Error from server:', result.message);
			}
		} catch (e) {
			console.error('Error loading similar trades:', e);
			errorMap.set(tradeId, `Error loading similar trades: ${e}`);
		} finally {
			loadingMap.delete(tradeId);
			similarTradesMap = similarTradesMap;
		}
	}

	// Modified reactive statement with more logging
	$: {
		if (expandedRows) {
			console.log('Expanded rows changed:', expandedRows);
			expandedRows.forEach((isExpanded, index) => {
				console.log(`Checking row ${index}, expanded: ${isExpanded}`);
				if (isExpanded && $list[index]) {
					const content = expandedContent($list[index]);
					console.log(`Content for row ${index}:`, content);
					if (content?.tradeId) {
						console.log(`Loading similar trades for row ${index}, tradeId: ${content.tradeId}`);
						loadSimilarTrades(content.tradeId);
					}
				}
			});
		}
	}
</script>

<div class="table-container">
	<table class="default-table">
		<thead>
			<tr class="default-tr">
				{#if expandable}
					<th class="default-th expand-column" />
				{/if}
				<th class="default-th"></th>
				{#each columns as col}
					<th class="default-th">{displayNames[col] || col}</th>
				{/each}
				<th class="default-th"></th>
			</tr>
		</thead>
		{#if Array.isArray($list) && $list.length > 0}
			<tbody>
				{#each $list as watch, i}
					<tr
						class="default-tr"
						on:mousedown={(event) => clickHandler(event, watch, i)}
						on:touchstart={handleTouchStart}
						on:touchend={handleTouchEnd}
						id="row-{i}"
						class:selected={i === selectedRowIndex}
						on:contextmenu={(event) => {
							event.preventDefault();
						}}
						class:expandable
						class:expanded={expandedRows.has(i)}
						on:click={() => expandable && toggleRow(i)}
					>
						{#if expandable}
							<td class="default-td expand-cell">
								<span class="expand-icon">{expandedRows.has(i) ? '−' : '+'}</span>
							</td>
						{/if}
						<td class="default-td">
							{#if isFlagged(watch, $flagWatchlist)}
								<span class="flag-icon">⚑</span>
							{/if}
						</td>
						{#each columns as col}
							{#if col === 'Ticker'}
								<td class="default-td">
									{#if iconsMap.has(watch.ticker)}
										<img src={iconsMap.get(watch.ticker)} alt="icon" class="ticker-icon" />
									{/if}
									{watch.ticker}
								</td>
							{:else if ['Price', 'Chg', 'Chg%', 'Ext'].includes(col)}
								<td class="default-td">
									<StreamCell
										on:contextmenu={(event) => {
											event.preventDefault();
											event.stopPropagation();
										}}
										instance={watch}
										type={(() => {
											switch (col) {
												case 'Price':
													return 'price';
												case 'Chg':
													return 'change';
												case 'Chg%':
													return 'change %';
												case 'Ext':
													return 'change % extended';
												default:
													return col.toLowerCase();
											}
										})()}
									/>
								</td>
							{:else if col === 'Timestamp'}
								<td
									class="default-td"
									on:contextmenu={(event) => {
										event.preventDefault();
										event.stopPropagation();
									}}>{UTCTimestampToESTString(watch[col.toLowerCase()])}</td
								>
							{:else}
								<td
									class="default-td"
									on:contextmenu={(event) => {
										event.preventDefault();
										event.stopPropagation();
									}}>{formatValue(watch, col)}</td
								>
							{/if}
						{/each}
						<td class="default-td">
							<button
								class="delete-button"
								on:click={(event) => {
									deleteRow(event, watch);
								}}
							>
								✕
							</button>
						</td>
					</tr>
					{#if expandable && expandedRows.has(i)}
						<tr class="expanded-content">
							<td colspan={columns.length + (expandable ? 2 : 1)}>
								<div class="trade-details">
									<h4>Trade Details</h4>
									<table>
										<thead>
											<tr class="defalt-tr">
												<th class="defalt-th">Time</th>
												<th class="defalt-th">Type</th>
												<th class="defalt-th">Price</th>
												<th class="defalt-th">Shares</th>
											</tr>
										</thead>
										<tbody>
											{#each getAllOrders(watch) as order}
												<tr class="defalt-tr">
													<td class="defalt-td">{UTCTimestampToESTString(order.time)}</td>
													<td class={order.type.toLowerCase().replace(/\s+/g, '-')}>{order.type}</td
													>
													<td class="defalt-td">{order.price}</td>
													<td class="defalt-td">{order.shares}</td>
												</tr>
											{/each}
										</tbody>
									</table>

									<!-- Add Similar Trades section -->
									{#if expandedContent}
										{@const content = expandedContent($list[i])}
										{@const tradeId = content.tradeId}
										{#if tradeId}
											<h4>Similar Trades</h4>
											{#if loadingMap.get(tradeId)}
												<div class="loading">Loading similar trades...</div>
											{:else if errorMap.get(tradeId)}
												<div class="error">{errorMap.get(tradeId)}</div>
											{:else if similarTradesMap.get(tradeId)?.length}
												<table>
													<thead>
														<tr class="defalt-tr">
															<th class="defalt-th">Date</th>
															<th class="defalt-th">Ticker</th>
															<th class="defalt-th">Direction</th>
															<th class="defalt-th">P/L</th>
															<th class="defalt-th">Similarity</th>
														</tr>
													</thead>
													<tbody>
														{#each similarTradesMap.get(tradeId) as similarTrade}
															<tr class="defalt-tr">
																<td class="defalt-td">
																	{UTCTimestampToESTString(similarTrade.entry_time)}
																</td>
																<td class="defalt-td">{similarTrade.ticker}</td>
																<td class="defalt-td">{similarTrade.direction}</td>
																<td class={similarTrade.pnl >= 0 ? 'positive' : 'negative'}>
																	${similarTrade.pnl.toFixed(2)}
																</td>
																<td class="defalt-td">
																	{(similarTrade.similarity_score * 100).toFixed(1)}%
																</td>
															</tr>
														{/each}
													</tbody>
												</table>
											{:else}
												<div class="no-results">No similar trades found</div>
											{/if}
										{/if}
									{/if}
								</div>
							</td>
						</tr>
					{/if}
				{/each}
			</tbody>
		{/if}
	</table>
</div>

<style>
	.selected {
		outline: 2px solid var(--ui-accent);
		outline-offset: -2px;
	}

	tr {
		transition: outline 0.2s ease;
	}

	.list-container {
		width: 100%;
		overflow-x: auto;
	}

	table {
		width: 100%;
		border-collapse: collapse;
		margin: 0;
		padding: 0;
		color: var(--text-primary);
		background: var(--ui-bg-primary);
		table-layout: fixed;
	}

	th,
	td {
		padding: 8px;
		text-align: left;
		border-bottom: 1px solid var(--ui-border);
	}

	th {
		background-color: var(--ui-bg-element);
		font-weight: bold;
		color: var(--text-secondary);
	}

	tr {
		background-color: var(--ui-bg-primary);
		transition: background-color 0.2s;
	}

	tr:hover {
		background-color: var(--ui-bg-hover);
	}

	.expandable {
		cursor: pointer;
	}

	.expand-cell {
		width: 30px;
		text-align: center;
		padding: 4px;
	}

	.expand-icon {
		color: var(--text-secondary);
	}

	.expanded-content {
		background-color: var(--ui-bg-element);
	}

	.expanded-content td {
		padding: 8px;
	}

	.trade-details {
		background-color: var(--ui-bg-element);
		padding: 8px;
		border-radius: 4px;
	}

	.trade-details h4 {
		margin: 0 0 6px 0;
		color: var(--text-secondary);
		font-size: 0.9em;
	}

	.trade-details table {
		width: 100%;
		font-size: 0.85em;
	}

	.trade-details th {
		background-color: var(--ui-bg-element);
		padding: 6px 8px;
	}

	.trade-details tr {
		background-color: transparent;
	}

	.trade-details tr:hover {
		background-color: var(--ui-bg-hover);
	}

	.entry,
	.buy {
		color: var(--positive);
	}

	.exit,
	.sell {
		color: var(--negative);
	}

	.short {
		color: var(--negative);
	}

	.buy-to-cover {
		color: var(--positive);
	}

	.table-container {
		width: 100%;
		overflow: hidden;
		max-width: 100%;
		padding-bottom: 2px;
		padding-right: 8px;
	}

	td:last-child {
		position: sticky;
		right: 8px;
		width: 24px;
		max-width: 24px;
		padding: 0;
		text-align: center;
	}

	th:last-child {
		position: sticky;
		right: 8px;
		width: 24px;
		max-width: 24px;
		padding: 0;
		background-color: var(--ui-bg-element);
	}

	.delete-button {
		opacity: 0;
		transition: opacity 0.2s ease;
	}

	tr:hover .delete-button {
		opacity: 1;
	}

	tr:hover td {
		background-color: var(--ui-bg-hover);
	}

	tr:hover td:last-child {
		background-color: var(--ui-bg-hover);
	}

	.loading,
	.error,
	.no-results {
		padding: 10px;
		text-align: center;
		color: var(--text-secondary);
	}

	.error {
		color: var(--negative);
	}

	.positive {
		color: var(--positive);
	}

	.negative {
		color: var(--negative);
	}

	h4 {
		margin: 20px 0 10px 0;
		color: var(--text-secondary);
	}

	.ticker-icon {
		width: 20px;
		height: 20px;
		margin-right: 5px;
		vertical-align: middle;
	}
</style>


<file>backend/tasks/security.go</file>
package tasks

import (
	"backend/utils"
	"context"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/jackc/pgx/v4"
)

type GetCurrentTickerArgs struct {
	SecurityId int `json:"securityId"`
}

func GetCurrentTicker(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetCurrentTickerArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("di1n0fni0: %v", err)
	}
	var ticker string
	err := conn.DB.QueryRow(context.Background(), "SELECT ticker FROM securities WHERE securityid=$1 AND maxDate is NULL", args.SecurityId).Scan(&ticker)
	if err == pgx.ErrNoRows {
		return "delisted", nil
	} else if err != nil {
		return nil, fmt.Errorf("k01n0v0e: %v", err)
	}
	return ticker, nil
}

type GetMarketCapArgs struct {
	Ticker string `json:"ticker"`
}

type GetMarketCapResults struct {
	MarketCap int `json:"marketCap"`
}

func GetMarketCap(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetMarketCapArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("di1n0fni0: %v", err)
	}

	details, err := utils.GetTickerDetails(conn.Polygon, args.Ticker, "now")
	if err != nil {
		return nil, fmt.Errorf("k01n0v0e: %v", err)
	}

	if details.MarketCap == 0 {
		return GetMarketCapResults{MarketCap: 0}, nil
	}

	return GetMarketCapResults{MarketCap: int(details.MarketCap)}, nil
}

type GetPrevCloseArgs struct {
	SecurityId int `json:"securityId"`
	Timestamp  int `json:"timestamp"`
}

type PolygonBar struct {
	Close float64 `json:"close"`
}

func GetPrevClose(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetPrevCloseArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("getPrevClose invalid args: %v", err)
	}

	// Start at the given timestamp and subtract a day until a valid close is found
	currentDay := time.Unix(int64(args.Timestamp/1000), 0).UTC()
	currentDay = currentDay.AddDate(0, 0, -1)

	var bar PolygonBar
	var ticker string
	maxDaysToCheck := 10
	daysChecked := 0
	for daysChecked < maxDaysToCheck {
		// Check if it's a weekend (Saturday or Sunday)
		if currentDay.Weekday() == time.Saturday || currentDay.Weekday() == time.Sunday {
			// If it's a weekend, subtract another day
			currentDay = currentDay.AddDate(0, 0, -1)
			continue
		}

		// Format the current day as yyyy-mm-dd
		date := currentDay.Format("2006-01-02")

		// Query the ticker for the given securityId and date range
		query := `SELECT ticker FROM securities WHERE securityid=$1 AND (minDate <= $2 AND (maxDate IS NULL or maxDate >= $2))`
		err := conn.DB.QueryRow(context.Background(), query, args.SecurityId, date).Scan(&ticker)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve ticker: %v", err)
		}

		// Make a request to Polygon's API for that date and ticker
		endpoint := fmt.Sprintf("https://api.polygon.io/v1/open-close/%s/%s?adjusted=true&apiKey=%s", ticker, date, conn.PolygonKey)
		resp, err := http.Get(endpoint)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch Polygon snapshot: %v", err)
		}
		defer resp.Body.Close()

		// Read the response body
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response: %v", err)
		}

		// Unmarshal the response into a PolygonBar struct
		if err := json.Unmarshal(body, &bar); err != nil {
			return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
		}

		// If the close price is found, return it
		if bar.Close != 0 {
			fmt.Println(currentDay)
			return bar.Close, nil
		}

		// If not a valid market day (e.g., holiday or no trading), go back one day
		currentDay = currentDay.AddDate(0, 0, -1)
		daysChecked++
	}
	return nil, fmt.Errorf("dn10vn20")

}

type GetSecurityFromTickerArgs struct {
	Ticker string `json:"ticker"`
}

type GetSecurityFromTickerResults struct {
	SecurityId int    `json:"securityId"`
	Ticker     string `json:"ticker"`
	Timestamp  int64  `json:"timestamp"`
	Icon       string `json:"icon"`
	Name       string `json:"name"`
}

func GetSecuritiesFromTicker(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetSecurityFromTickerArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("getAnnotations invalid args: %v", err)
	}

	// Clean and prepare the search query
	query := strings.ToUpper(strings.TrimSpace(args.Ticker))

	// Modified query to properly handle name and icon and prioritize active securities
	sqlQuery := `
	WITH ranked_results AS (
		SELECT DISTINCT ON (s.ticker) 
			securityId, 
			ticker,
			NULLIF(name, '') as name,
			NULLIF(icon, '') as icon, 
			maxDate,
			CASE 
				WHEN UPPER(ticker) = UPPER($1) THEN 1
				WHEN UPPER(ticker) LIKE UPPER($1) || '%' THEN 2
				WHEN UPPER(ticker) LIKE '%' || UPPER($1) || '%' THEN 3
				ELSE 4
			END as match_type,
			similarity(UPPER(ticker), UPPER($1)) as sim_score,
			CASE 
				WHEN maxDate IS NULL THEN 0
				ELSE 1
			END as is_delisted
		FROM securities s
		WHERE (
			UPPER(ticker) = UPPER($1) OR
			UPPER(ticker) LIKE UPPER($1) || '%' OR 
			UPPER(ticker) LIKE '%' || UPPER($1) || '%' OR
			similarity(UPPER(ticker), UPPER($1)) > 0.3
		)
		ORDER BY ticker, maxDate DESC NULLS FIRST
	)
	SELECT securityId, ticker, name, icon, maxDate
	FROM ranked_results
	ORDER BY match_type, is_delisted, sim_score DESC
	LIMIT 10
	`

	rows, err := conn.DB.Query(context.Background(), sqlQuery, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var securities []GetSecurityFromTickerResults
	for rows.Next() {
		var security GetSecurityFromTickerResults
		var timestamp sql.NullTime
		var name, icon sql.NullString
		if err := rows.Scan(&security.SecurityId, &security.Ticker, &name, &icon, &timestamp); err != nil {
			return nil, err
		}
		if timestamp.Valid {
			security.Timestamp = timestamp.Time.UnixMilli()
		} else {
			security.Timestamp = 0
		}
		// Properly assign name and icon from NullString
		security.Name = name.String
		security.Icon = icon.String
		securities = append(securities, security)
	}
	return securities, nil
}

type GetTickerDetailsArgs struct {
	SecurityId int    `json:"securityId"`
	Ticker     string `json:"ticker,omitempty"`
	Timestamp  int64  `json:"timestamp,omitempty"`
}

type GetTickerMenuDetailsResults struct {
	Ticker                      string          `json:"ticker"`
	Name                        sql.NullString  `json:"name"`
	Market                      sql.NullString  `json:"market"`
	Locale                      sql.NullString  `json:"locale"`
	PrimaryExchange             sql.NullString  `json:"primary_exchange"`
	Active                      string          `json:"active"`
	MarketCap                   sql.NullFloat64 `json:"market_cap"`
	Description                 sql.NullString  `json:"description"`
	Logo                        sql.NullString  `json:"logo"`
	Icon                        sql.NullString  `json:"icon"`
	ShareClassSharesOutstanding sql.NullInt64   `json:"share_class_shares_outstanding"`
	Industry                    sql.NullString  `json:"industry"`
	Sector                      sql.NullString  `json:"sector"`
	TotalShares                 sql.NullInt64   `json:"totalShares"`
}

func GetTickerMenuDetails(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetTickerDetailsArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("invalid args: %v", err)
	}

	// Modified query to handle NULL market_cap
	query := `
		SELECT 
			ticker,
			NULLIF(name, '') as name,
			NULLIF(market, '') as market,
			NULLIF(locale, '') as locale,
			NULLIF(primary_exchange, '') as primary_exchange,
			CASE 
				WHEN maxDate IS NULL THEN 'Now'
				ELSE to_char(maxDate, 'YYYY-MM-DD')
			END as active,
			NULLIF(market_cap, 0),  -- This will convert 0 to NULL
			NULLIF(description, '') as description,
			NULLIF(logo, '') as logo,
			NULLIF(icon, '') as icon,
			share_class_shares_outstanding,
			NULLIF(industry, '') as industry,
			NULLIF(sector, '') as sector,
			total_shares
		FROM securities 
		WHERE securityId = $1 AND (maxDate IS NULL OR maxDate = (
			SELECT MAX(maxDate) 
			FROM securities 
			WHERE securityId = $1
		))`

	var results GetTickerMenuDetailsResults
	err := conn.DB.QueryRow(context.Background(), query, args.SecurityId).Scan(
		&results.Ticker,
		&results.Name,
		&results.Market,
		&results.Locale,
		&results.PrimaryExchange,
		&results.Active,
		&results.MarketCap,
		&results.Description,
		&results.Logo,
		&results.Icon,
		&results.ShareClassSharesOutstanding,
		&results.Industry,
		&results.Sector,
		&results.TotalShares,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get ticker details: %v", err)
	}

	// Create a map to store the results and handle NULL values
	response := map[string]interface{}{
		"ticker":                         results.Ticker,
		"name":                           results.Name.String,
		"market":                         results.Market.String,
		"locale":                         results.Locale.String,
		"primary_exchange":               results.PrimaryExchange.String,
		"active":                         results.Active,
		"market_cap":                     nil,
		"description":                    results.Description.String,
		"logo":                           results.Logo.String,
		"icon":                           results.Icon.String,
		"share_class_shares_outstanding": nil,
		"industry":                       results.Industry.String,
		"sector":                         results.Sector.String,
		"totalShares":                    nil,
	}

	// Only include market_cap if it's valid
	if results.MarketCap.Valid {
		response["market_cap"] = results.MarketCap.Float64
	}

	// Only include totalShares if it's valid
	if results.TotalShares.Valid {
		response["totalShares"] = results.TotalShares.Int64
	}

	// Only include share_class_shares_outstanding if it's valid
	if results.ShareClassSharesOutstanding.Valid {
		response["share_class_shares_outstanding"] = results.ShareClassSharesOutstanding.Int64
	}

	return response, nil
}

type TickerDetailsResponse struct {
	Ticker                      string  `json:"ticker"`
	Name                        string  `json:"name"`
	Market                      string  `json:"market"`
	Locale                      string  `json:"locale"`
	PrimaryExchange             string  `json:"primary_exchange"`
	Active                      bool    `json:"active"`
	MarketCap                   float64 `json:"market_cap"`
	Description                 string  `json:"description"`
	Logo                        string  `json:"logo"`
	Icon                        string  `json:"icon"`
	ShareClassSharesOutstanding int64   `json:"share_class_shares_outstanding"`
	Industry                    string  `json:"industry"`
	Sector                      string  `json:"sector"`
}

func GetTickerDetails(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetTickerDetailsArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("invalid args: %v", err)
	}
	tim := time.UnixMilli(args.Timestamp)

	var ticker string
	var err error
	if args.Ticker == "" {
		ticker, err = utils.GetTicker(conn, args.SecurityId, tim)
		if err != nil {
			return nil, fmt.Errorf("failed to get ticker: %s: %v", args.Ticker, err)
		}
	} else {
		ticker = args.Ticker
	}
	details, err := utils.GetTickerDetails(conn.Polygon, ticker, "now")
	if err != nil {
		fmt.Println("failed to get ticker details: %v", err)
		return nil, nil
		//return nil, fmt.Errorf("failed to get ticker details: %v", err)
	}

	var sector, industry string
	err = conn.DB.QueryRow(context.Background(), `SELECT sector, industry from securities 
    where securityId = $1 and maxDate is NULL`, args.SecurityId).Scan(&sector, &industry)
	if err != nil {
		return nil, fmt.Errorf("01if0d %v", err)
	}

	// Helper function to fetch and encode image data
	fetchImage := func(url string) (string, error) {
		if url == "" {
			return "", nil
		}

		client := &http.Client{}
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return "", fmt.Errorf("failed to create request: %v", err)
		}
		req.Header.Add("Authorization", "Bearer "+conn.PolygonKey)

		resp, err := client.Do(req)
		if err != nil {
			return "", fmt.Errorf("failed to fetch image: %v", err)
		}
		defer resp.Body.Close()

		imageData, err := io.ReadAll(resp.Body)
		if err != nil {
			return "", fmt.Errorf("failed to read image data: %v", err)
		}

		return base64.StdEncoding.EncodeToString(imageData), nil
	}

	// Fetch both logo and icon

	logoBase64, err := fetchImage(details.Branding.LogoURL)
	iconBase64, err := fetchImage(details.Branding.IconURL)
	/*
		if err != nil {
			return nil, fmt.Errorf("failed to fetch logo: %v", err)	const defaultIcons = {
			stock: '<svg>...</svg>', // Add your default SVG content
			fund: '<svg>...</svg>',
			futures: '<svg>...</svg>',
			forex: '<svg>...</svg>',
			indices: '<svg>...</svg>'
		} as const;*/

	response := TickerDetailsResponse{
		Ticker:                      details.Ticker,
		Name:                        details.Name,
		Market:                      string(details.Market),
		Locale:                      string(details.Locale),
		PrimaryExchange:             details.PrimaryExchange,
		Active:                      details.Active,
		MarketCap:                   details.MarketCap,
		Description:                 details.Description,
		ShareClassSharesOutstanding: details.ShareClassSharesOutstanding,
		Logo:                        logoBase64,
		Icon:                        iconBase64,
		Sector:                      sector,
		Industry:                    industry,
	}

	return response, nil
}

type GetSecurityClassificationsResults struct {
	Sectors    []string `json:"sectors"`
	Industries []string `json:"industries"`
}

func GetSecurityClassifications(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	// Query to get unique sectors, excluding NULL values and empty strings
	sectorQuery := `
		SELECT DISTINCT sector 
		FROM securities 
		WHERE sector IS NOT NULL 
		AND sector != '' 
		AND maxDate IS NULL 
		ORDER BY sector
	`

	industryQuery := `
		SELECT DISTINCT industry 
		FROM securities 
		WHERE industry IS NOT NULL 
		AND industry != '' 
		AND maxDate IS NULL 
		ORDER BY industry
	`

	sectorRows, err := conn.DB.Query(context.Background(), sectorQuery)
	if err != nil {
		return nil, fmt.Errorf("failed to query sectors: %v", err)
	}
	defer sectorRows.Close()

	var sectors []string
	for sectorRows.Next() {
		var sector string
		if err := sectorRows.Scan(&sector); err != nil {
			return nil, fmt.Errorf("failed to scan sector: %v", err)
		}
		sectors = append(sectors, sector)
	}

	if err := sectorRows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating over sectors: %v", err)
	}

	industryRows, err := conn.DB.Query(context.Background(), industryQuery)
	if err != nil {
		return nil, fmt.Errorf("failed to query industries: %v", err)
	}
	defer industryRows.Close()

	var industries []string
	for industryRows.Next() {
		var industry string
		if err := industryRows.Scan(&industry); err != nil {
			return nil, fmt.Errorf("failed to scan industry: %v", err)
		}
		industries = append(industries, industry)
	}

	if err := industryRows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating over industries: %v", err)
	}

	return GetSecurityClassificationsResults{
		Sectors:    sectors,
		Industries: industries,
	}, nil
}

type GetEdgarFilingsArgs struct {
	SecurityId int    `json:"securityId"`
	Timestamp  int64  `json:"timestamp"`
	From       *int64 `json:"from,omitempty"`
	To         *int64 `json:"to,omitempty"`
	Limit      int    `json:"limit,omitempty"`
}

func GetEdgarFilings(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetEdgarFilingsArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("invalid args: %v", err)
	}

	// Set default timestamp to now if not provided
	if args.Timestamp == 0 {
		args.Timestamp = time.Now().UnixMilli()
	}

	// Create EdgarFilingOptions from the args
	var opts *utils.EdgarFilingOptions
	if args.From != nil || args.To != nil || args.Limit > 0 {
		opts = &utils.EdgarFilingOptions{
			Limit: args.Limit,
		}

		// Convert From timestamp if provided
		if args.From != nil {
			fromTime := time.UnixMilli(*args.From)
			opts.From = &fromTime
		}

		// Convert To timestamp if provided
		if args.To != nil {
			if *args.To == 0 {
				now := time.Now()
				opts.To = &now
			} else {
				toTime := time.UnixMilli(*args.To)
				opts.To = &toTime
			}
		}
	}

	filings, err := utils.GetRecentEdgarFilings(conn, args.SecurityId, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to get EDGAR filings: %v", err)
	}

	return filings, nil
}

type GetIconsArgs struct {
	Tickers []string `json:"tickers"`
}

type GetIconsResults struct {
	Ticker string `json:"ticker"`
	Icon   string `json:"icon"`
}

func GetIcons(conn *utils.Conn, userId int, rawArgs json.RawMessage) (interface{}, error) {
	var args GetIconsArgs
	if err := json.Unmarshal(rawArgs, &args); err != nil {
		return nil, fmt.Errorf("invalid args: %v", err)
	}

	// Prepare a query to fetch icons for the given tickers
	query := `
		SELECT ticker, icon
		FROM securities
		WHERE ticker = ANY($1)
	`

	rows, err := conn.DB.Query(context.Background(), query, args.Tickers)
	if err != nil {
		return nil, fmt.Errorf("failed to query icons: %v", err)
	}
	defer rows.Close()

	var results []GetIconsResults
	for rows.Next() {
		var result GetIconsResults
		if err := rows.Scan(&result.Ticker, &result.Icon); err != nil {
			return nil, fmt.Errorf("failed to scan icon: %v", err)
		}
		results = append(results, result)
	}

	return results, nil
}


<file>frontend/src/lib/features/quotes/quote.svelte</file>
<script lang="ts">
	import L1 from './l1.svelte';
	import TimeAndSales from './timeAndSales.svelte';
	import { get, writable, type Writable } from 'svelte/store';
	import { queryInstanceInput } from '$lib/utils/popups/input.svelte';
	import type { Instance } from '$lib/core/types';
	import { activeChartInstance, queryChart } from '$lib/features/chart/interface';
	import StreamCell from '$lib/utils/stream/streamCell.svelte';
	import { streamInfo, formatTimestamp } from '$lib/core/stores';
	import { onMount } from 'svelte';
	import { privateRequest } from '$lib/core/backend';

	let instance: Writable<Instance> = writable({});
	let container: HTMLDivElement;
	let showTimeAndSales = false;

	// Sync instance with activeChartInstance
	activeChartInstance.subscribe((chartInstance) => {
		if (chartInstance) {
			instance.set(chartInstance);
		}
	});

	function handleKey(event: KeyboardEvent) {
		// Example: if user presses tab or alphanumeric, prompt ticker change
		if (event.key == 'Tab' || /^[a-zA-Z0-9]$/.test(event.key)) {
			const current = get(instance);
			queryInstanceInput(['ticker'], ['ticker'], current)
				.then((updated: Instance) => {
					instance.set(updated);
				})
				.catch(() => {});
		}
	}

	function toggleTimeAndSales() {
		showTimeAndSales = !showTimeAndSales;
	}

	function handleClick(event: MouseEvent | TouchEvent) {
		if ($activeChartInstance) {
			queryChart($activeChartInstance);
		}
	}

	$: if (container) {
		container.addEventListener('keydown', handleKey);
	}

	onMount(() => {
		activeChartInstance.subscribe((instance: Instance | null) => {
			if (instance && !instance.detailsFetched && instance.securityId) {
				privateRequest('getTickerMenuDetails', { securityId: instance.securityId }, true).then(
					(details) => {
						activeChartInstance.update((inst: Instance) => ({
							...inst,
							...details,
							detailsFetched: true
						}));
					}
				);
			}
		});

		document.addEventListener('mousemove', handleMouseMove);
		document.addEventListener('mouseup', handleMouseUp);

		return () => {
			document.removeEventListener('mousemove', handleMouseMove);
			document.removeEventListener('mouseup', handleMouseUp);
		};
	});

	function handleMouseMove(e: MouseEvent | TouchEvent) {
		// This function is now empty as the height-related variables and functions are removed
	}

	function handleMouseUp() {
		// This function is now empty as the height-related variables and functions are removed
	}
</script>

<div
	class="ticker-info-container"
	bind:this={container}
	on:click={handleClick}
	on:touchstart={handleClick}
>
	<div class="content">
		<div class="ticker-container">
			<div class="ticker-display">
				<span class="ticker">{$instance.ticker || '--'}</span>
			</div>
		</div>

		{#if $activeChartInstance?.logo}
			<div class="logo-container">
				<img
					src="data:image/svg+xml;base64,{$activeChartInstance.logo}"
					alt="{$activeChartInstance.name} logo"
					class="company-logo"
				/>
			</div>
		{/if}

		<div class="stream-cells">
			<div class="stream-cell-container">
				<span class="label">Price</span>
				<StreamCell instance={$activeChartInstance} type="price" />
			</div>
			<div class="stream-cell-container">
				<span class="label">Chg %</span>
				<StreamCell instance={$activeChartInstance} type="change %" />
			</div>
			<div class="stream-cell-container">
				<span class="label">Chg $</span>
				<StreamCell instance={$activeChartInstance} type="change" />
			</div>
			<div class="stream-cell-container">
				<span class="label">Ext %</span>
				<StreamCell instance={$activeChartInstance} type="change % extended" />
			</div>
		</div>

		<div class="quotes-section">
			<L1 {instance} />
			<button class="time-sales-button" on:click|stopPropagation={toggleTimeAndSales}>
				{showTimeAndSales ? 'Hide Time & Sales' : 'Show Time & Sales'}
			</button>
			{#if showTimeAndSales}
				<TimeAndSales {instance} />
			{/if}
		</div>

		<div class="info-row">
			<span class="label">Name:</span>
			<span class="value">{$activeChartInstance?.name}</span>
		</div>
		<div class="info-row">
			<span class="label">Active:</span>
			<span class="value">{$activeChartInstance?.active || 'N/A'}</span>
		</div>
		<div class="info-row">
			<span class="label">Market Cap:</span>
			<span class="value">
				{#if $activeChartInstance?.totalShares}
					<StreamCell instance={$activeChartInstance} type="market cap" />
				{:else}
					N/A
				{/if}
			</span>
		</div>
		<div class="info-row">
			<span class="label">Sector:</span>
			<span class="value">{$activeChartInstance?.sector || 'N/A'}</span>
		</div>
		<div class="info-row">
			<span class="label">Industry:</span>
			<span class="value">{$activeChartInstance?.industry || 'N/A'}</span>
		</div>
		<div class="info-row">
			<span class="label">Exchange:</span>
			<span class="value">{$activeChartInstance?.primary_exchange || 'N/A'}</span>
		</div>
		<div class="info-row">
			<span class="label">Market:</span>
			<span class="value">{$activeChartInstance?.market || 'N/A'}</span>
		</div>
		<div class="info-row">
			<span class="label">Shares Out:</span>
			<span class="value">
				{#if $activeChartInstance?.share_class_shares_outstanding}
					{($activeChartInstance.share_class_shares_outstanding / 1e6).toFixed(2)}M
				{:else}
					N/A
				{/if}
			</span>
		</div>
		{#if $activeChartInstance?.description}
			<div class="description">
				<span class="label">Description:</span>
				<p class="value description-text">{$activeChartInstance?.description}</p>
			</div>
		{/if}
	</div>
</div>

<style>
	.ticker-info-container {
		background: var(--ui-bg-primary);
		backdrop-filter: var(--backdrop-blur);
		border-top: 1px solid var(--ui-border);
		overflow: hidden;
		will-change: height;
		font-family: var(--font-primary);
		height: 100%;
	}

	.ticker-info-container.expanded {
		transition: none;
	}

	.ticker-info-container:not(.expanded) {
		transition: height 0.2s ease;
	}

	.content {
		padding: 15px;
		overflow-y: auto;
		scrollbar-width: none;
		-ms-overflow-style: none;
		height: 100%;
		color: var(--text-primary);
	}

	.content::-webkit-scrollbar {
		display: none;
	}

	.company-logo {
		max-height: 40px;
		max-width: 200px;
		object-fit: contain;
	}

	.ticker-display {
		font-family: var(--font-primary);
		font-size: 28px;
		font-weight: 600;
		color: var(--text-primary);
		background: var(--ui-bg-secondary);
		width: 100%;
		height: 50px;
		text-align: center;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 6px;
	}

	.ticker {
		letter-spacing: 0.5px;
		text-transform: uppercase;
	}

	.ticker-container {
		margin-bottom: 15px;
		padding: 0 15%; /* Add padding on sides to make ticker display narrower */
	}

	.description {
		margin-top: 15px;
		padding-top: 10px;
		border-top: 1px solid var(--ui-border);
	}

	.stream-cell-container {
		margin: 0;
		padding: 0;
		background: none;
		font-weight: 500;
		color: var(--text-secondary);
	}

	.logo-container {
		display: flex;
		justify-content: center;
		margin-bottom: 15px;
	}

	.stream-cells {
		display: grid;
		grid-template-columns: repeat(4, 1fr);
		gap: 8px;
		margin: 15px 0;
	}

	.stream-cell-container {
		margin: 0;
		padding: 0;
		background: none;
		font-weight: 500;
		color: var(--text-secondary);
		overflow: hidden;
	}

	.stream-cell-container .label {
		font-size: 0.85em;
		display: block;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		margin-bottom: 2px;
	}

	.time-sales-button {
		background: var(--ui-bg-secondary);
		color: var(--text-primary);
		border: 1px solid var(--ui-border);
		border-radius: 4px;
		padding: 6px 12px;
		font-size: 0.9em;
		cursor: pointer;
		transition: background-color 0.2s;
		margin: 10px 0;
		width: 100%;
	}

	.time-sales-button:hover {
		background: var(--ui-bg-hover);
	}

	.quotes-section {
		margin-top: 15px;
		border-top: 1px solid var(--ui-border);
		padding-top: 15px;
	}
</style>


</potential_codebase_context>
